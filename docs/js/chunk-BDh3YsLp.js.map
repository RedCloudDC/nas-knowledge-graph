{"version":3,"file":"chunk-BDh3YsLp.js","sources":["../../src/utils/search.js","../../src/utils/debounce.js","../../src/utils/filter.js","../../src/utils/urlStateManager.js"],"sourcesContent":["/**\n * Search Utility\n * Provides comprehensive search and query functionality for graph data\n */\nimport { store } from '../core/store.js';\n\nexport class Search {\n    constructor() {\n        this.searchIndex = new Map();\n        this.lastQuery = '';\n        this.searchHistory = [];\n        this.maxHistorySize = 50;\n    }\n\n    /**\n     * Build search index for fast text searching\n     */\n    buildIndex(nodes, edges) {\n        this.searchIndex.clear();\n\n        // Index nodes\n        nodes.forEach(node => {\n            const searchableText = this.extractSearchableText(node);\n            this.searchIndex.set(`node-${node.id}`, {\n                id: node.id,\n                type: 'node',\n                text: searchableText,\n                data: node\n            });\n        });\n\n        // Index edges\n        edges.forEach(edge => {\n            const searchableText = this.extractSearchableText(edge);\n            this.searchIndex.set(`edge-${edge.id}`, {\n                id: edge.id,\n                type: 'edge',\n                text: searchableText,\n                data: edge\n            });\n        });\n    }\n\n    /**\n     * Extract searchable text from node or edge\n     */\n    extractSearchableText(item) {\n        const texts = [];\n\n        // Add basic properties\n        if (item.label) {texts.push(item.label.toLowerCase());}\n        if (item.type) {texts.push(item.type.toLowerCase());}\n        if (item.id) {texts.push(String(item.id).toLowerCase());}\n\n        // Add properties\n        if (item.properties) {\n            Object.entries(item.properties).forEach(([key, value]) => {\n                texts.push(key.toLowerCase());\n                texts.push(String(value).toLowerCase());\n            });\n        }\n\n        return texts.join(' ');\n    }\n\n    /**\n     * Perform text search across nodes and edges\n     */\n    textSearch(query, options = {}) {\n        const {\n            caseSensitive = false,\n            exactMatch = false,\n            searchNodes = true,\n            searchEdges = true,\n            limit = 100\n        } = options;\n\n        if (!query) {return [];}\n\n        const searchQuery = caseSensitive ? query : query.toLowerCase();\n        const results = [];\n\n        this.searchIndex.forEach((item, key) => {\n            if (!searchNodes && item.type === 'node') {return;}\n            if (!searchEdges && item.type === 'edge') {return;}\n\n            let matches = false;\n\n            if (exactMatch) {\n                matches = item.text.includes(searchQuery);\n            } else {\n                // Fuzzy matching\n                matches = this.fuzzyMatch(item.text, searchQuery);\n            }\n\n            if (matches) {\n                results.push({\n                    ...item,\n                    score: this.calculateRelevanceScore(item.text, searchQuery)\n                });\n            }\n\n            if (results.length >= limit) {return false;} // Break iteration\n        });\n\n        // Sort by relevance score\n        results.sort((a, b) => b.score - a.score);\n\n        // Add to search history\n        this.addToHistory(query);\n\n        return results;\n    }\n\n    /**\n     * Search nodes by specific criteria\n     */\n    searchNodes(criteria = {}) {\n        const { nodes } = store.getState();\n\n        return nodes.filter(node => {\n            return this.matchesCriteria(node, criteria);\n        });\n    }\n\n    /**\n     * Search edges by specific criteria\n     */\n    searchEdges(criteria = {}) {\n        const { edges } = store.getState();\n\n        return edges.filter(edge => {\n            return this.matchesCriteria(edge, criteria);\n        });\n    }\n\n    /**\n     * Find nodes by type\n     */\n    findNodesByType(nodeType) {\n        const { nodes } = store.getState();\n        return nodes.filter(node => node.type === nodeType);\n    }\n\n    /**\n     * Find connected nodes\n     */\n    findConnectedNodes(nodeId, options = {}) {\n        const { maxDepth = 1, direction = 'both' } = options;\n        const { nodes, edges } = store.getState();\n\n        const visited = new Set();\n        const result = [];\n        const queue = [{ id: nodeId, depth: 0 }];\n\n        while (queue.length > 0) {\n            const { id, depth } = queue.shift();\n\n            if (visited.has(id) || depth > maxDepth) {continue;}\n            visited.add(id);\n\n            if (depth > 0) {\n                const node = nodes.find(n => n.id === id);\n                if (node) {result.push(node);}\n            }\n\n            if (depth < maxDepth) {\n                const connections = this.getNodeConnections(id, edges, direction);\n                connections.forEach(connectedId => {\n                    if (!visited.has(connectedId)) {\n                        queue.push({ id: connectedId, depth: depth + 1 });\n                    }\n                });\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Find shortest path between nodes\n     */\n    findPath(sourceId, targetId, options = {}) {\n        const { maxDepth = 10, weighted = false } = options;\n        const { edges } = store.getState();\n\n        if (sourceId === targetId) {return [sourceId];}\n\n        const queue = [{ id: sourceId, path: [sourceId], depth: 0 }];\n        const visited = new Set();\n\n        while (queue.length > 0) {\n            const { id, path, depth } = queue.shift();\n\n            if (visited.has(id) || depth > maxDepth) {continue;}\n            visited.add(id);\n\n            const connections = this.getNodeConnections(id, edges, 'both');\n\n            for (const connectedId of connections) {\n                if (connectedId === targetId) {\n                    return [...path, connectedId];\n                }\n\n                if (!visited.has(connectedId)) {\n                    queue.push({\n                        id: connectedId,\n                        path: [...path, connectedId],\n                        depth: depth + 1\n                    });\n                }\n            }\n        }\n\n        return null; // No path found\n    }\n\n    /**\n     * Advanced search with multiple filters\n     */\n    advancedSearch(filters = {}) {\n        const {\n            text = '',\n            nodeTypes = [],\n            edgeTypes = [],\n            properties = {},\n            dateRange = null,\n            minConnections = null,\n            maxConnections = null\n        } = filters;\n\n        let results = { nodes: [], edges: [] };\n\n        // Start with text search if provided\n        if (text) {\n            const textResults = this.textSearch(text);\n            results.nodes = textResults.filter(r => r.type === 'node').map(r => r.data);\n            results.edges = textResults.filter(r => r.type === 'edge').map(r => r.data);\n        } else {\n            const state = store.getState();\n            results.nodes = [...state.nodes];\n            results.edges = [...state.edges];\n        }\n\n        // Apply node type filters\n        if (nodeTypes.length > 0) {\n            results.nodes = results.nodes.filter(node => nodeTypes.includes(node.type));\n        }\n\n        // Apply edge type filters\n        if (edgeTypes.length > 0) {\n            results.edges = results.edges.filter(edge => edgeTypes.includes(edge.type));\n        }\n\n        // Apply property filters\n        if (Object.keys(properties).length > 0) {\n            results.nodes = results.nodes.filter(node =>\n                this.matchesProperties(node, properties)\n            );\n            results.edges = results.edges.filter(edge =>\n                this.matchesProperties(edge, properties)\n            );\n        }\n\n        // Apply connection count filters\n        if (minConnections !== null || maxConnections !== null) {\n            const { edges } = store.getState();\n            results.nodes = results.nodes.filter(node => {\n                const connectionCount = this.getNodeConnectionCount(node.id, edges);\n                return (minConnections === null || connectionCount >= minConnections) &&\n                       (maxConnections === null || connectionCount <= maxConnections);\n            });\n        }\n\n        return results;\n    }\n\n    /**\n     * Suggest search terms based on current data\n     */\n    getSuggestions(partialQuery, limit = 10) {\n        if (!partialQuery) {return [];}\n\n        const query = partialQuery.toLowerCase();\n        const suggestions = new Set();\n\n        this.searchIndex.forEach(item => {\n            const words = item.text.split(' ');\n            words.forEach(word => {\n                if (word.startsWith(query) && word.length > query.length) {\n                    suggestions.add(word);\n                }\n            });\n        });\n\n        return Array.from(suggestions).slice(0, limit);\n    }\n\n    /**\n     * Get search history\n     */\n    getSearchHistory() {\n        return [...this.searchHistory].reverse();\n    }\n\n    /**\n     * Clear search history\n     */\n    clearSearchHistory() {\n        this.searchHistory = [];\n    }\n\n    /**\n     * Helper methods\n     */\n    matchesCriteria(item, criteria) {\n        for (const [key, value] of Object.entries(criteria)) {\n            if (!this.matchesCriterion(item, key, value)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    matchesCriterion(item, key, value) {\n        if (key === 'text') {\n            const searchableText = this.extractSearchableText(item);\n            return this.fuzzyMatch(searchableText, value.toLowerCase());\n        }\n\n        if (key === 'type') {\n            return Array.isArray(value) ? value.includes(item.type) : item.type === value;\n        }\n\n        if (key === 'id') {\n            return Array.isArray(value) ? value.includes(item.id) : item.id === value;\n        }\n\n        if (key === 'properties') {\n            return this.matchesProperties(item, value);\n        }\n\n        return item[key] === value;\n    }\n\n    matchesProperties(item, propertyFilters) {\n        if (!item.properties) {return Object.keys(propertyFilters).length === 0;}\n\n        for (const [propKey, propValue] of Object.entries(propertyFilters)) {\n            if (!item.properties.hasOwnProperty(propKey)) {return false;}\n\n            const itemValue = item.properties[propKey];\n\n            if (typeof propValue === 'object' && propValue.operator) {\n                if (!this.matchesOperator(itemValue, propValue.value, propValue.operator)) {\n                    return false;\n                }\n            } else if (itemValue !== propValue) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    matchesOperator(itemValue, filterValue, operator) {\n        switch (operator) {\n        case 'eq': return itemValue === filterValue;\n        case 'ne': return itemValue !== filterValue;\n        case 'gt': return itemValue > filterValue;\n        case 'gte': return itemValue >= filterValue;\n        case 'lt': return itemValue < filterValue;\n        case 'lte': return itemValue <= filterValue;\n        case 'contains': return String(itemValue).toLowerCase().includes(String(filterValue).toLowerCase());\n        case 'startsWith': return String(itemValue).toLowerCase().startsWith(String(filterValue).toLowerCase());\n        case 'endsWith': return String(itemValue).toLowerCase().endsWith(String(filterValue).toLowerCase());\n        case 'regex': return new RegExp(filterValue, 'i').test(String(itemValue));\n        default: return itemValue === filterValue;\n        }\n    }\n\n    getNodeConnections(nodeId, edges, direction = 'both') {\n        const connections = [];\n\n        edges.forEach(edge => {\n            if (direction === 'both' || direction === 'out') {\n                if (edge.source === nodeId) {connections.push(edge.target);}\n            }\n            if (direction === 'both' || direction === 'in') {\n                if (edge.target === nodeId) {connections.push(edge.source);}\n            }\n        });\n\n        return connections;\n    }\n\n    getNodeConnectionCount(nodeId, edges) {\n        return edges.filter(edge =>\n            edge.source === nodeId || edge.target === nodeId\n        ).length;\n    }\n\n    fuzzyMatch(text, query) {\n        // Simple fuzzy matching - checks if all query characters appear in order\n        let queryIndex = 0;\n\n        for (let i = 0; i < text.length && queryIndex < query.length; i++) {\n            if (text[i] === query[queryIndex]) {\n                queryIndex++;\n            }\n        }\n\n        return queryIndex === query.length;\n    }\n\n    calculateRelevanceScore(text, query) {\n        let score = 0;\n\n        // Exact match bonus\n        if (text.includes(query)) {score += 100;}\n\n        // Starting with query bonus\n        if (text.startsWith(query)) {score += 50;}\n\n        // Word boundary match bonus\n        const words = text.split(' ');\n        words.forEach(word => {\n            if (word.startsWith(query)) {score += 25;}\n            if (word === query) {score += 75;}\n        });\n\n        // Length penalty (prefer shorter matches)\n        score -= text.length * 0.1;\n\n        return Math.max(0, score);\n    }\n\n    addToHistory(query) {\n        if (!query || query === this.lastQuery) {return;}\n\n        // Remove existing entry if present\n        const existingIndex = this.searchHistory.indexOf(query);\n        if (existingIndex > -1) {\n            this.searchHistory.splice(existingIndex, 1);\n        }\n\n        // Add to front\n        this.searchHistory.unshift(query);\n\n        // Trim to max size\n        if (this.searchHistory.length > this.maxHistorySize) {\n            this.searchHistory = this.searchHistory.slice(0, this.maxHistorySize);\n        }\n\n        this.lastQuery = query;\n    }\n\n    /**\n     * Search within node neighborhoods\n     */\n    searchNeighborhood(nodeId, query, depth = 1) {\n        const connectedNodes = this.findConnectedNodes(nodeId, { maxDepth: depth });\n\n        if (!query) {return connectedNodes;}\n\n        return connectedNodes.filter(node => {\n            const searchableText = this.extractSearchableText(node);\n            return this.fuzzyMatch(searchableText, query.toLowerCase());\n        });\n    }\n\n    /**\n     * Create saved search\n     */\n    saveSearch(name, filters) {\n        const savedSearches = this.getSavedSearches();\n        savedSearches[name] = {\n            filters,\n            created: new Date().toISOString(),\n            lastUsed: new Date().toISOString()\n        };\n\n        localStorage.setItem('kg-saved-searches', JSON.stringify(savedSearches));\n    }\n\n    /**\n     * Get saved searches\n     */\n    getSavedSearches() {\n        try {\n            return JSON.parse(localStorage.getItem('kg-saved-searches') || '{}');\n        } catch {\n            return {};\n        }\n    }\n\n    /**\n     * Execute saved search\n     */\n    executeSavedSearch(name) {\n        const savedSearches = this.getSavedSearches();\n        const search = savedSearches[name];\n\n        if (!search) {throw new Error(`Saved search '${name}' not found`);}\n\n        // Update last used\n        search.lastUsed = new Date().toISOString();\n        localStorage.setItem('kg-saved-searches', JSON.stringify(savedSearches));\n\n        return this.advancedSearch(search.filters);\n    }\n\n    /**\n     * Update search index when data changes\n     */\n    updateIndex() {\n        const { nodes, edges } = store.getState();\n        this.buildIndex(nodes, edges);\n    }\n}\n\n// Create and export singleton search instance\nexport const search = new Search();\n\n// Initialize search index when store changes\nstore.subscribe('nodes', () => search.updateIndex());\nstore.subscribe('edges', () => search.updateIndex());\n","/**\n * Debounce Utility\n * Provides debouncing functionality for performance optimization\n */\n\n/**\n * Creates a debounced function that delays invoking func until after wait milliseconds\n * have elapsed since the last time the debounced function was invoked\n */\nexport function debounce(func, wait, immediate = false) {\n    let timeout;\n\n    return function executedFunction(...args) {\n        const later = () => {\n            timeout = null;\n            if (!immediate) {func.apply(this, args);}\n        };\n\n        const callNow = immediate && !timeout;\n\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n\n        if (callNow) {func.apply(this, args);}\n    };\n}\n\n/**\n * Creates a throttled function that only invokes func at most once per every wait milliseconds\n */\nexport function throttle(func, wait) {\n    let inThrottle;\n\n    return function(...args) {\n        if (!inThrottle) {\n            func.apply(this, args);\n            inThrottle = true;\n\n            setTimeout(() => {\n                inThrottle = false;\n            }, wait);\n        }\n    };\n}\n\n/**\n * Cancellable debounce that returns both the debounced function and a cancel method\n */\nexport function cancellableDebounce(func, wait, immediate = false) {\n    let timeout;\n\n    const debounced = function executedFunction(...args) {\n        const later = () => {\n            timeout = null;\n            if (!immediate) {func.apply(this, args);}\n        };\n\n        const callNow = immediate && !timeout;\n\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n\n        if (callNow) {func.apply(this, args);}\n    };\n\n    debounced.cancel = () => {\n        clearTimeout(timeout);\n        timeout = null;\n    };\n\n    return debounced;\n}\n\n/**\n * Advanced debounce with leading and trailing options\n */\nexport function advancedDebounce(func, wait, options = {}) {\n    const { leading = false, trailing = true, maxWait } = options;\n    let timeout;\n    let maxTimeout;\n    let result;\n    let lastCallTime;\n    let lastInvokeTime = 0;\n\n    function invokeFunc(time) {\n        const args = lastArgs;\n        const thisArg = lastThis;\n\n        lastArgs = lastThis = undefined;\n        lastInvokeTime = time;\n        result = func.apply(thisArg, args);\n        return result;\n    }\n\n    function leadingEdge(time) {\n        // Reset any maxWait timer\n        lastInvokeTime = time;\n        // Start the timer for the trailing edge\n        timeout = setTimeout(timerExpired, wait);\n        // Invoke the leading edge\n        return leading ? invokeFunc(time) : result;\n    }\n\n    function remainingWait(time) {\n        const timeSinceLastCall = time - lastCallTime;\n        const timeSinceLastInvoke = time - lastInvokeTime;\n        const timeWaiting = wait - timeSinceLastCall;\n\n        return maxWait !== undefined\n            ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\n            : timeWaiting;\n    }\n\n    function shouldInvoke(time) {\n        const timeSinceLastCall = time - lastCallTime;\n        const timeSinceLastInvoke = time - lastInvokeTime;\n\n        // Either this is the first call, activity has stopped and we're at the trailing edge,\n        // the system time has gone backwards and we're treating it as the trailing edge,\n        // or we've hit the maxWait limit.\n        return (lastCallTime === undefined ||\n                (timeSinceLastCall >= wait) ||\n                (timeSinceLastCall < 0) ||\n                (maxWait !== undefined && timeSinceLastInvoke >= maxWait));\n    }\n\n    function timerExpired() {\n        const time = Date.now();\n        if (shouldInvoke(time)) {\n            return trailingEdge(time);\n        }\n        // Restart the timer\n        timeout = setTimeout(timerExpired, remainingWait(time));\n    }\n\n    function trailingEdge(time) {\n        timeout = undefined;\n\n        // Only invoke if we have lastArgs which means func has been debounced at least once\n        if (trailing && lastArgs) {\n            return invokeFunc(time);\n        }\n        lastArgs = lastThis = undefined;\n        return result;\n    }\n\n    function cancel() {\n        if (timeout !== undefined) {\n            clearTimeout(timeout);\n        }\n        if (maxTimeout !== undefined) {\n            clearTimeout(maxTimeout);\n        }\n        lastInvokeTime = 0;\n        lastArgs = lastCallTime = lastThis = timeout = maxTimeout = undefined;\n    }\n\n    function flush() {\n        return timeout === undefined ? result : trailingEdge(Date.now());\n    }\n\n    let lastArgs, lastThis;\n\n    function debounced(...args) {\n        const time = Date.now();\n        const isInvoking = shouldInvoke(time);\n\n        lastArgs = args;\n        lastThis = this;\n        lastCallTime = time;\n\n        if (isInvoking) {\n            if (timeout === undefined) {\n                return leadingEdge(lastCallTime);\n            }\n            if (maxWait) {\n                // Handle invocations in a tight loop\n                timeout = setTimeout(timerExpired, wait);\n                return invokeFunc(lastCallTime);\n            }\n        }\n        if (timeout === undefined) {\n            timeout = setTimeout(timerExpired, wait);\n        }\n        return result;\n    }\n\n    debounced.cancel = cancel;\n    debounced.flush = flush;\n\n    return debounced;\n}\n\n/**\n * Frame-based debouncing using requestAnimationFrame\n * Useful for DOM updates and animations\n */\nexport function frameDebounce(func) {\n    let frameId;\n\n    return function(...args) {\n        if (frameId) {\n            cancelAnimationFrame(frameId);\n        }\n\n        frameId = requestAnimationFrame(() => {\n            func.apply(this, args);\n        });\n    };\n}\n\n/**\n * Idle debounce - delays execution until the browser is idle\n */\nexport function idleDebounce(func, timeout = 5000) {\n    let idleId;\n\n    return function(...args) {\n        if (idleId) {\n            cancelIdleCallback(idleId);\n        }\n\n        if (window.requestIdleCallback) {\n            idleId = requestIdleCallback(() => {\n                func.apply(this, args);\n            }, { timeout });\n        } else {\n            // Fallback for browsers without requestIdleCallback\n            setTimeout(() => {\n                func.apply(this, args);\n            }, timeout);\n        }\n    };\n}\n\n/**\n * Creates a debounced search function specifically for search inputs\n */\nexport function createDebouncedSearch(searchFunction, delay = 300) {\n    const debouncedFn = debounce(searchFunction, delay);\n    let lastQuery = '';\n\n    return function(query) {\n        // Immediately clear results if query becomes empty\n        if (!query && lastQuery) {\n            searchFunction('');\n        }\n\n        lastQuery = query;\n\n        if (query) {\n            debouncedFn(query);\n        }\n    };\n}\n\n/**\n * Batch debounce - collects multiple calls and processes them in batches\n */\nexport function batchDebounce(func, wait = 100, batchSize = 10) {\n    let batch = [];\n    let timeout;\n\n    return function(item) {\n        batch.push(item);\n\n        if (batch.length >= batchSize) {\n            // Process immediately if batch is full\n            const items = batch.slice();\n            batch = [];\n            clearTimeout(timeout);\n            func(items);\n        } else {\n            // Set up delayed processing\n            clearTimeout(timeout);\n            timeout = setTimeout(() => {\n                if (batch.length > 0) {\n                    const items = batch.slice();\n                    batch = [];\n                    func(items);\n                }\n            }, wait);\n        }\n    };\n}\n\n/**\n * Performance monitoring wrapper for debounced functions\n */\nexport function monitoredDebounce(func, wait, name = 'debounced-function') {\n    const debouncedFn = debounce(func, wait);\n    let callCount = 0;\n    let executeCount = 0;\n    let totalExecutionTime = 0;\n\n    return function(...args) {\n        callCount++;\n\n        const wrappedFunc = (...innerArgs) => {\n            const startTime = performance.now();\n            executeCount++;\n\n            const result = func.apply(this, innerArgs);\n\n            const endTime = performance.now();\n            const executionTime = endTime - startTime;\n            totalExecutionTime += executionTime;\n\n            // Log performance data periodically\n            if (executeCount % 10 === 0) {\n                console.log(`Debounce Stats for ${name}:`, {\n                    calls: callCount,\n                    executions: executeCount,\n                    savings: `${((1 - executeCount / callCount) * 100).toFixed(1)}%`,\n                    avgExecutionTime: `${(totalExecutionTime / executeCount).toFixed(2)}ms`\n                });\n            }\n\n            return result;\n        };\n\n        return debounce(wrappedFunc, wait).apply(this, args);\n    };\n}\n\n// Export convenience functions for common use cases\nexport const searchDebounce = (func) => debounce(func, 300);\nexport const resizeDebounce = (func) => debounce(func, 150);\nexport const scrollDebounce = (func) => throttle(func, 16); // ~60fps\nexport const inputDebounce = (func) => debounce(func, 250);\nexport const clickDebounce = (func) => debounce(func, 500, true); // immediate execution\n","/**\n * Filter Utility\n * Provides filtering functionality for graph data manipulation\n */\nimport { store } from '../core/store.js';\n\nexport class Filter {\n    constructor() {\n        this.activeFilters = new Map();\n        this.filterHistory = [];\n        this.maxHistorySize = 20;\n    }\n\n    /**\n     * Apply multiple filters to graph data\n     */\n    applyFilters(filterConfig = {}) {\n        const { nodes, edges } = store.getState();\n\n        let filteredNodes = [...nodes];\n        let filteredEdges = [...edges];\n\n        // Apply node filters\n        if (filterConfig.nodes) {\n            filteredNodes = this.filterNodes(filteredNodes, filterConfig.nodes);\n        }\n\n        // Apply edge filters\n        if (filterConfig.edges) {\n            filteredEdges = this.filterEdges(filteredEdges, filterConfig.edges);\n        }\n\n        // Filter edges based on filtered nodes (remove edges with missing nodes)\n        if (filterConfig.cascadeEdges !== false) {\n            const nodeIds = new Set(filteredNodes.map(n => n.id));\n            filteredEdges = filteredEdges.filter(edge =>\n                nodeIds.has(edge.source) && nodeIds.has(edge.target)\n            );\n        }\n\n        return { nodes: filteredNodes, edges: filteredEdges };\n    }\n\n    /**\n     * Filter nodes based on criteria\n     */\n    filterNodes(nodes, criteria) {\n        return nodes.filter(node => this.nodeMatchesCriteria(node, criteria));\n    }\n\n    /**\n     * Filter edges based on criteria\n     */\n    filterEdges(edges, criteria) {\n        return edges.filter(edge => this.edgeMatchesCriteria(edge, criteria));\n    }\n\n    /**\n     * Check if node matches filter criteria\n     */\n    nodeMatchesCriteria(node, criteria) {\n        for (const [filterType, filterValue] of Object.entries(criteria)) {\n            if (!this.applyNodeFilter(node, filterType, filterValue)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Check if edge matches filter criteria\n     */\n    edgeMatchesCriteria(edge, criteria) {\n        for (const [filterType, filterValue] of Object.entries(criteria)) {\n            if (!this.applyEdgeFilter(edge, filterType, filterValue)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Apply specific filter to a node\n     */\n    applyNodeFilter(node, filterType, filterValue) {\n        switch (filterType) {\n        case 'type':\n            return this.filterByType(node.type, filterValue);\n\n        case 'label':\n            return this.filterByText(node.label, filterValue);\n\n        case 'id':\n            return this.filterById(node.id, filterValue);\n\n        case 'properties':\n            return this.filterByProperties(node.properties || {}, filterValue);\n\n        case 'connections':\n            return this.filterByConnectionCount(node.id, filterValue);\n\n        case 'degree':\n            return this.filterByDegree(node.id, filterValue);\n\n        case 'custom':\n            return this.filterByCustomFunction(node, filterValue);\n\n        default:\n            return true;\n        }\n    }\n\n    /**\n     * Apply specific filter to an edge\n     */\n    applyEdgeFilter(edge, filterType, filterValue) {\n        switch (filterType) {\n        case 'type':\n            return this.filterByType(edge.type, filterValue);\n\n        case 'label':\n            return this.filterByText(edge.label, filterValue);\n\n        case 'id':\n            return this.filterById(edge.id, filterValue);\n\n        case 'properties':\n            return this.filterByProperties(edge.properties || {}, filterValue);\n\n        case 'source':\n            return this.filterById(edge.source, filterValue);\n\n        case 'target':\n            return this.filterById(edge.target, filterValue);\n\n        case 'custom':\n            return this.filterByCustomFunction(edge, filterValue);\n\n        default:\n            return true;\n        }\n    }\n\n    /**\n     * Filter by type (single value or array)\n     */\n    filterByType(itemType, filterValue) {\n        if (Array.isArray(filterValue)) {\n            return filterValue.includes(itemType);\n        }\n        if (typeof filterValue === 'object' && filterValue.operator) {\n            return this.applyOperator(itemType, filterValue.value, filterValue.operator);\n        }\n        return itemType === filterValue;\n    }\n\n    /**\n     * Filter by text content\n     */\n    filterByText(itemText, filterValue) {\n        if (!itemText) {return !filterValue;}\n\n        if (typeof filterValue === 'string') {\n            return itemText.toLowerCase().includes(filterValue.toLowerCase());\n        }\n\n        if (typeof filterValue === 'object') {\n            const { value, operator = 'contains', caseSensitive = false } = filterValue;\n            const text = caseSensitive ? itemText : itemText.toLowerCase();\n            const searchValue = caseSensitive ? value : value.toLowerCase();\n\n            switch (operator) {\n            case 'equals':\n                return text === searchValue;\n            case 'contains':\n                return text.includes(searchValue);\n            case 'startsWith':\n                return text.startsWith(searchValue);\n            case 'endsWith':\n                return text.endsWith(searchValue);\n            case 'regex':\n                return new RegExp(value, caseSensitive ? 'g' : 'gi').test(itemText);\n            default:\n                return text.includes(searchValue);\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Filter by ID\n     */\n    filterById(itemId, filterValue) {\n        if (Array.isArray(filterValue)) {\n            return filterValue.includes(itemId);\n        }\n        if (typeof filterValue === 'object' && filterValue.operator) {\n            return this.applyOperator(itemId, filterValue.value, filterValue.operator);\n        }\n        return itemId === filterValue;\n    }\n\n    /**\n     * Filter by properties\n     */\n    filterByProperties(itemProperties, filterValue) {\n        if (typeof filterValue !== 'object') {return false;}\n\n        for (const [propKey, propFilter] of Object.entries(filterValue)) {\n            if (!itemProperties.hasOwnProperty(propKey)) {\n                return false;\n            }\n\n            const propValue = itemProperties[propKey];\n\n            if (typeof propFilter === 'object' && propFilter.operator) {\n                if (!this.applyOperator(propValue, propFilter.value, propFilter.operator)) {\n                    return false;\n                }\n            } else {\n                if (propValue !== propFilter) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Filter by connection count\n     */\n    filterByConnectionCount(nodeId, filterValue) {\n        const { edges } = store.getState();\n        const connectionCount = edges.filter(edge =>\n            edge.source === nodeId || edge.target === nodeId\n        ).length;\n\n        if (typeof filterValue === 'number') {\n            return connectionCount === filterValue;\n        }\n\n        if (typeof filterValue === 'object') {\n            return this.applyOperator(connectionCount, filterValue.value, filterValue.operator);\n        }\n\n        return false;\n    }\n\n    /**\n     * Filter by degree (in, out, or both)\n     */\n    filterByDegree(nodeId, filterValue) {\n        const { edges } = store.getState();\n\n        const inDegree = edges.filter(edge => edge.target === nodeId).length;\n        const outDegree = edges.filter(edge => edge.source === nodeId).length;\n        const totalDegree = inDegree + outDegree;\n\n        const { type = 'total', operator = 'eq', value } = filterValue;\n\n        let degreeValue;\n        switch (type) {\n        case 'in':\n            degreeValue = inDegree;\n            break;\n        case 'out':\n            degreeValue = outDegree;\n            break;\n        case 'total':\n        default:\n            degreeValue = totalDegree;\n            break;\n        }\n\n        return this.applyOperator(degreeValue, value, operator);\n    }\n\n    /**\n     * Filter by custom function\n     */\n    filterByCustomFunction(item, filterFunction) {\n        if (typeof filterFunction !== 'function') {return true;}\n        return filterFunction(item);\n    }\n\n    /**\n     * Apply comparison operator\n     */\n    applyOperator(itemValue, filterValue, operator) {\n        switch (operator) {\n        case 'eq':\n        case '=':\n        case '==':\n            return itemValue === filterValue;\n\n        case 'ne':\n        case '!=':\n            return itemValue !== filterValue;\n\n        case 'gt':\n        case '>':\n            return itemValue > filterValue;\n\n        case 'gte':\n        case '>=':\n            return itemValue >= filterValue;\n\n        case 'lt':\n        case '<':\n            return itemValue < filterValue;\n\n        case 'lte':\n        case '<=':\n            return itemValue <= filterValue;\n\n        case 'in':\n            return Array.isArray(filterValue) && filterValue.includes(itemValue);\n\n        case 'nin':\n            return Array.isArray(filterValue) && !filterValue.includes(itemValue);\n\n        case 'between':\n            return Array.isArray(filterValue) &&\n                       filterValue.length === 2 &&\n                       itemValue >= filterValue[0] &&\n                       itemValue <= filterValue[1];\n\n        case 'contains':\n            return String(itemValue).toLowerCase().includes(String(filterValue).toLowerCase());\n\n        case 'startsWith':\n            return String(itemValue).toLowerCase().startsWith(String(filterValue).toLowerCase());\n\n        case 'endsWith':\n            return String(itemValue).toLowerCase().endsWith(String(filterValue).toLowerCase());\n\n        case 'regex':\n            return new RegExp(filterValue, 'i').test(String(itemValue));\n\n        default:\n            return itemValue === filterValue;\n        }\n    }\n\n    /**\n     * Create a named filter set\n     */\n    createFilterSet(name, config) {\n        this.activeFilters.set(name, {\n            config,\n            created: new Date().toISOString(),\n            active: true\n        });\n\n        this.addToHistory({ name, config, action: 'create' });\n        return this.applyFilters(config);\n    }\n\n    /**\n     * Update existing filter set\n     */\n    updateFilterSet(name, config) {\n        if (!this.activeFilters.has(name)) {\n            throw new Error(`Filter set '${name}' not found`);\n        }\n\n        this.activeFilters.set(name, {\n            ...this.activeFilters.get(name),\n            config,\n            updated: new Date().toISOString()\n        });\n\n        this.addToHistory({ name, config, action: 'update' });\n        return this.applyAllActiveFilters();\n    }\n\n    /**\n     * Remove filter set\n     */\n    removeFilterSet(name) {\n        if (this.activeFilters.has(name)) {\n            const filterSet = this.activeFilters.get(name);\n            this.activeFilters.delete(name);\n            this.addToHistory({ name, config: filterSet.config, action: 'remove' });\n        }\n\n        return this.applyAllActiveFilters();\n    }\n\n    /**\n     * Toggle filter set active state\n     */\n    toggleFilterSet(name, active = null) {\n        if (!this.activeFilters.has(name)) {return null;}\n\n        const filterSet = this.activeFilters.get(name);\n        const newActiveState = active !== null ? active : !filterSet.active;\n\n        this.activeFilters.set(name, {\n            ...filterSet,\n            active: newActiveState\n        });\n\n        this.addToHistory({ name, config: filterSet.config, action: newActiveState ? 'activate' : 'deactivate' });\n        return this.applyAllActiveFilters();\n    }\n\n    /**\n     * Apply all active filter sets\n     */\n    applyAllActiveFilters() {\n        const { nodes, edges } = store.getState();\n        let result = { nodes: [...nodes], edges: [...edges] };\n\n        for (const [name, filterSet] of this.activeFilters.entries()) {\n            if (filterSet.active) {\n                result = this.applyFilters({\n                    ...filterSet.config,\n                    nodes: result.nodes,\n                    edges: result.edges\n                });\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Get all active filter sets\n     */\n    getActiveFilters() {\n        const activeFilters = {};\n        this.activeFilters.forEach((filterSet, name) => {\n            if (filterSet.active) {\n                activeFilters[name] = filterSet;\n            }\n        });\n        return activeFilters;\n    }\n\n    /**\n     * Get all filter sets (active and inactive)\n     */\n    getAllFilters() {\n        const allFilters = {};\n        this.activeFilters.forEach((filterSet, name) => {\n            allFilters[name] = filterSet;\n        });\n        return allFilters;\n    }\n\n    /**\n     * Clear all filters\n     */\n    clearAllFilters() {\n        this.activeFilters.clear();\n        this.addToHistory({ action: 'clear_all' });\n\n        const { nodes, edges } = store.getState();\n        return { nodes, edges };\n    }\n\n    /**\n     * Create common filters\n     */\n    createNodeTypeFilter(nodeTypes) {\n        return this.createFilterSet('nodeType', {\n            nodes: { type: nodeTypes }\n        });\n    }\n\n    createConnectionFilter(minConnections = 0, maxConnections = null) {\n        const connectionFilter = { operator: 'gte', value: minConnections };\n        if (maxConnections !== null) {\n            connectionFilter.operator = 'between';\n            connectionFilter.value = [minConnections, maxConnections];\n        }\n\n        return this.createFilterSet('connections', {\n            nodes: { connections: connectionFilter }\n        });\n    }\n\n    createPropertyFilter(propertyName, propertyValue, operator = 'eq') {\n        return this.createFilterSet(`property-${propertyName}`, {\n            nodes: {\n                properties: {\n                    [propertyName]: { operator, value: propertyValue }\n                }\n            }\n        });\n    }\n\n    createTextFilter(searchText, field = 'label') {\n        return this.createFilterSet('textSearch', {\n            nodes: {\n                [field]: { value: searchText, operator: 'contains' }\n            }\n        });\n    }\n\n    /**\n     * Create filter from search results\n     */\n    createFilterFromSearch(searchResults, name = 'searchFilter') {\n        const nodeIds = searchResults.nodes.map(n => n.id);\n        const edgeIds = searchResults.edges.map(e => e.id);\n\n        return this.createFilterSet(name, {\n            nodes: { id: nodeIds },\n            edges: { id: edgeIds }\n        });\n    }\n\n    /**\n     * Export filters to JSON\n     */\n    exportFilters() {\n        const filters = {};\n        this.activeFilters.forEach((filterSet, name) => {\n            filters[name] = {\n                config: filterSet.config,\n                active: filterSet.active,\n                created: filterSet.created,\n                updated: filterSet.updated\n            };\n        });\n        return JSON.stringify(filters, null, 2);\n    }\n\n    /**\n     * Import filters from JSON\n     */\n    importFilters(filtersJson) {\n        try {\n            const filters = JSON.parse(filtersJson);\n\n            Object.entries(filters).forEach(([name, filterSet]) => {\n                this.activeFilters.set(name, {\n                    config: filterSet.config,\n                    active: filterSet.active !== false,\n                    created: filterSet.created || new Date().toISOString(),\n                    updated: filterSet.updated,\n                    imported: new Date().toISOString()\n                });\n            });\n\n            this.addToHistory({ action: 'import', count: Object.keys(filters).length });\n            return this.applyAllActiveFilters();\n        } catch (error) {\n            throw new Error('Invalid filter configuration JSON');\n        }\n    }\n\n    /**\n     * Get filter statistics\n     */\n    getFilterStats() {\n        const { nodes, edges } = store.getState();\n        const filtered = this.applyAllActiveFilters();\n\n        return {\n            original: {\n                nodes: nodes.length,\n                edges: edges.length\n            },\n            filtered: {\n                nodes: filtered.nodes.length,\n                edges: filtered.edges.length\n            },\n            reduction: {\n                nodes: nodes.length - filtered.nodes.length,\n                edges: edges.length - filtered.edges.length,\n                nodesPercent: nodes.length > 0 ? ((1 - filtered.nodes.length / nodes.length) * 100).toFixed(1) : 0,\n                edgesPercent: edges.length > 0 ? ((1 - filtered.edges.length / edges.length) * 100).toFixed(1) : 0\n            },\n            activeFilters: Array.from(this.activeFilters.keys()).filter(name =>\n                this.activeFilters.get(name).active\n            ).length\n        };\n    }\n\n    /**\n     * Add action to history\n     */\n    addToHistory(action) {\n        this.filterHistory.unshift({\n            ...action,\n            timestamp: new Date().toISOString()\n        });\n\n        // Trim history to max size\n        if (this.filterHistory.length > this.maxHistorySize) {\n            this.filterHistory = this.filterHistory.slice(0, this.maxHistorySize);\n        }\n    }\n\n    /**\n     * Get filter history\n     */\n    getFilterHistory() {\n        return [...this.filterHistory];\n    }\n\n    /**\n     * Clear filter history\n     */\n    clearFilterHistory() {\n        this.filterHistory = [];\n    }\n}\n\n/**\n * Quick filter functions for common use cases\n */\nexport const QuickFilters = {\n    /**\n     * Show only nodes of specified types\n     */\n    byNodeType: (nodeTypes) => {\n        if (!Array.isArray(nodeTypes)) {nodeTypes = [nodeTypes];}\n        return { nodes: { type: nodeTypes } };\n    },\n\n    /**\n     * Show only highly connected nodes\n     */\n    byHighConnectivity: (minConnections = 3) => {\n        return { nodes: { connections: { operator: 'gte', value: minConnections } } };\n    },\n\n    /**\n     * Show nodes matching text in label\n     */\n    byLabel: (searchText) => {\n        return { nodes: { label: { value: searchText, operator: 'contains' } } };\n    },\n\n    /**\n     * Show nodes with specific property values\n     */\n    byProperty: (propertyName, value, operator = 'eq') => {\n        return {\n            nodes: {\n                properties: {\n                    [propertyName]: { operator, value }\n                }\n            }\n        };\n    },\n\n    /**\n     * Show only leaf nodes (nodes with one or no connections)\n     */\n    leafNodes: () => {\n        return { nodes: { connections: { operator: 'lte', value: 1 } } };\n    },\n\n    /**\n     * Show only hub nodes (nodes with many connections)\n     */\n    hubNodes: (threshold = 5) => {\n        return { nodes: { connections: { operator: 'gte', value: threshold } } };\n    }\n};\n\n// Create and export singleton filter instance\nexport const filter = new Filter();\n","/**\n * URL State Manager\n * Manages URL hash for persisting and sharing filter states, search queries, and view settings\n */\n\nimport { store } from '../core/store.js';\n\nexport class URLStateManager {\n    constructor() {\n        this.stateVersion = '1.0';\n        this.maxUrlLength = 2048; // Browser URL length limit\n        this.compressionEnabled = true;\n        this.debounceDelay = 500;\n        this.updateTimeout = null;\n\n        this.stateKeys = {\n            // Filter states\n            filters: 'f',\n            search: 's',\n            selectedNode: 'n',\n            selectedEdge: 'e',\n\n            // View states\n            graphView: 'v',\n            sidePanel: 'p',\n            theme: 't',\n            layout: 'l',\n\n            // Explorer states\n            exploredNodes: 'ex',\n            pathfinding: 'pf',\n\n            // Data states\n            dataSource: 'd',\n            timestamp: 'ts'\n        };\n\n        this.reverseStateKeys = Object.fromEntries(\n            Object.entries(this.stateKeys).map(([key, value]) => [value, key])\n        );\n\n        this.init();\n    }\n\n    /**\n     * Initialize the URL state manager\n     */\n    init() {\n        // Load state from URL on initialization\n        this.loadStateFromUrl();\n\n        // Setup event listeners\n        this.setupEventListeners();\n\n        // Setup store subscriptions\n        this.setupStoreSubscriptions();\n\n        console.log('🔗 URL State Manager initialized');\n    }\n\n    /**\n     * Setup event listeners for browser navigation and custom events\n     */\n    setupEventListeners() {\n        // Handle browser back/forward navigation\n        window.addEventListener('popstate', (e) => {\n            if (e.state && e.state.appState) {\n                this.restoreState(e.state.appState);\n            } else {\n                this.loadStateFromUrl();\n            }\n        });\n\n        // Handle hash changes\n        window.addEventListener('hashchange', () => {\n            this.loadStateFromUrl();\n        });\n\n        // Listen for filter changes\n        document.addEventListener('filtersApplied', (e) => {\n            this.updateUrlState('filters', e.detail.filterState);\n        });\n\n        // Listen for search changes\n        document.addEventListener('globalSearch', (e) => {\n            this.updateUrlState('search', {\n                query: e.detail.query,\n                scope: e.detail.scope,\n                timestamp: e.detail.timestamp\n            });\n        });\n\n        // Listen for view changes\n        document.addEventListener('layoutChange', (e) => {\n            this.updateUrlState('layout', e.detail.layout);\n        });\n\n        // Listen for node selections\n        document.addEventListener('nodeSelected', (e) => {\n            this.updateUrlState('selectedNode', e.detail.nodeId);\n        });\n\n        // Listen for exploration state changes\n        document.addEventListener('explorationStateChanged', (e) => {\n            this.updateUrlState('exploredNodes', Array.from(e.detail.exploredNodes));\n        });\n    }\n\n    /**\n     * Setup store subscriptions to track state changes\n     */\n    setupStoreSubscriptions() {\n        // Track selected node changes\n        store.subscribe('selectedNode', (node) => {\n            const nodeId = node ? node.id : null;\n            this.updateUrlState('selectedNode', nodeId);\n        });\n\n        // Track graph view changes\n        store.subscribe('graphView', (graphView) => {\n            this.updateUrlState('graphView', {\n                zoom: graphView.zoom,\n                center: graphView.center,\n                layout: graphView.layout\n            });\n        });\n\n        // Track side panel state\n        store.subscribe('sidePanel', (sidePanel) => {\n            this.updateUrlState('sidePanel', {\n                visible: sidePanel.visible,\n                activeTab: sidePanel.activeTab\n            });\n        });\n    }\n\n    /**\n     * Update URL state with new data\n     */\n    updateUrlState(key, value, immediate = false) {\n        // Clear existing timeout\n        if (this.updateTimeout) {\n            clearTimeout(this.updateTimeout);\n        }\n\n        // Update state immediately or with debounce\n        const updateFn = () => {\n            this.setUrlState(key, value);\n        };\n\n        if (immediate) {\n            updateFn();\n        } else {\n            this.updateTimeout = setTimeout(updateFn, this.debounceDelay);\n        }\n    }\n\n    /**\n     * Set URL state for a specific key\n     */\n    setUrlState(key, value) {\n        try {\n            const currentState = this.parseUrlHash();\n\n            if (value === null || value === undefined ||\n                (Array.isArray(value) && value.length === 0) ||\n                (typeof value === 'object' && Object.keys(value).length === 0)) {\n                delete currentState[this.stateKeys[key]];\n            } else {\n                currentState[this.stateKeys[key]] = value;\n            }\n\n            currentState[this.stateKeys.timestamp] = Date.now();\n\n            const newHash = this.buildUrlHash(currentState);\n\n            // Check URL length limit\n            if (newHash.length > this.maxUrlLength) {\n                console.warn('URL state too long, applying compression');\n                const compressedState = this.compressState(currentState);\n                const compressedHash = this.buildUrlHash(compressedState);\n\n                if (compressedHash.length <= this.maxUrlLength) {\n                    this.setUrlHash(compressedHash);\n                } else {\n                    console.error('State too large even after compression');\n                }\n            } else {\n                this.setUrlHash(newHash);\n            }\n\n            // Update browser history\n            this.pushStateToHistory(currentState);\n\n        } catch (error) {\n            console.error('Failed to update URL state:', error);\n        }\n    }\n\n    /**\n     * Load complete state from current URL\n     */\n    loadStateFromUrl() {\n        try {\n            const urlState = this.parseUrlHash();\n            const appState = this.convertToAppState(urlState);\n\n            if (Object.keys(appState).length > 0) {\n                this.applyStateToApp(appState);\n                console.log('📥 Loaded state from URL:', appState);\n            }\n        } catch (error) {\n            console.error('Failed to load state from URL:', error);\n        }\n    }\n\n    /**\n     * Parse URL hash into state object\n     */\n    parseUrlHash() {\n        const hash = window.location.hash.substring(1);\n        if (!hash) {return {};}\n\n        try {\n            // Handle compressed state\n            if (hash.startsWith('c:')) {\n                return this.decompressState(hash.substring(2));\n            }\n\n            // Handle base64 encoded state\n            if (this.isBase64(hash)) {\n                const decoded = atob(hash);\n                return JSON.parse(decoded);\n            }\n\n            // Handle URL parameters format\n            const params = new URLSearchParams(hash);\n            const state = {};\n\n            for (const [key, value] of params.entries()) {\n                try {\n                    state[key] = JSON.parse(decodeURIComponent(value));\n                } catch {\n                    state[key] = decodeURIComponent(value);\n                }\n            }\n\n            return state;\n        } catch (error) {\n            console.warn('Failed to parse URL hash:', error);\n            return {};\n        }\n    }\n\n    /**\n     * Build URL hash from state object\n     */\n    buildUrlHash(state) {\n        if (Object.keys(state).length === 0) {return '';}\n\n        try {\n            // Try base64 encoding first (most compact)\n            const json = JSON.stringify(state);\n            const base64 = btoa(json);\n\n            if (base64.length < this.maxUrlLength) {\n                return base64;\n            }\n\n            // Fall back to URL parameters format\n            const params = new URLSearchParams();\n\n            for (const [key, value] of Object.entries(state)) {\n                if (value !== null && value !== undefined) {\n                    const serialized = typeof value === 'object'\n                        ? JSON.stringify(value)\n                        : String(value);\n                    params.set(key, serialized);\n                }\n            }\n\n            return params.toString();\n        } catch (error) {\n            console.error('Failed to build URL hash:', error);\n            return '';\n        }\n    }\n\n    /**\n     * Set URL hash without triggering hashchange event\n     */\n    setUrlHash(hash) {\n        const currentHash = window.location.hash.substring(1);\n        if (currentHash !== hash) {\n            // Use replaceState to avoid triggering navigation\n            const newUrl = hash ? `${window.location.pathname}#${hash}` : window.location.pathname;\n            window.history.replaceState(null, '', newUrl);\n        }\n    }\n\n    /**\n     * Push current state to browser history\n     */\n    pushStateToHistory(state) {\n        const appState = this.convertToAppState(state);\n\n        window.history.replaceState(\n            { appState, timestamp: Date.now() },\n            document.title,\n            window.location.href\n        );\n    }\n\n    /**\n     * Convert URL state keys to application state keys\n     */\n    convertToAppState(urlState) {\n        const appState = {};\n\n        for (const [shortKey, value] of Object.entries(urlState)) {\n            const fullKey = this.reverseStateKeys[shortKey];\n            if (fullKey) {\n                appState[fullKey] = value;\n            }\n        }\n\n        return appState;\n    }\n\n    /**\n     * Apply loaded state to application\n     */\n    applyStateToApp(appState) {\n        // Apply filters\n        if (appState.filters) {\n            document.dispatchEvent(new CustomEvent('applyUrlFilters', {\n                detail: { filters: appState.filters }\n            }));\n        }\n\n        // Apply search\n        if (appState.search) {\n            document.dispatchEvent(new CustomEvent('applyUrlSearch', {\n                detail: appState.search\n            }));\n        }\n\n        // Apply selected node\n        if (appState.selectedNode) {\n            store.setState({\n                selectedNode: this.findNodeById(appState.selectedNode)\n            });\n        }\n\n        // Apply graph view settings\n        if (appState.graphView) {\n            store.setState({ graphView: appState.graphView });\n        }\n\n        // Apply side panel settings\n        if (appState.sidePanel) {\n            store.setState({ sidePanel: appState.sidePanel });\n        }\n\n        // Apply theme\n        if (appState.theme) {\n            document.dispatchEvent(new CustomEvent('applyTheme', {\n                detail: { theme: appState.theme }\n            }));\n        }\n\n        // Apply layout\n        if (appState.layout) {\n            document.dispatchEvent(new CustomEvent('applyLayout', {\n                detail: { layout: appState.layout }\n            }));\n        }\n\n        // Apply exploration state\n        if (appState.exploredNodes) {\n            document.dispatchEvent(new CustomEvent('applyExplorationState', {\n                detail: { exploredNodes: new Set(appState.exploredNodes) }\n            }));\n        }\n\n        // Apply pathfinding state\n        if (appState.pathfinding) {\n            document.dispatchEvent(new CustomEvent('applyPathfindingState', {\n                detail: appState.pathfinding\n            }));\n        }\n    }\n\n    /**\n     * Find node by ID in store\n     */\n    findNodeById(nodeId) {\n        const { nodes } = store.getState();\n        return nodes.find(node => node.id.toString() === nodeId.toString());\n    }\n\n    /**\n     * Compress state for shorter URLs\n     */\n    compressState(state) {\n        const compressed = {};\n\n        // Remove timestamp for compression\n        const { ts, ...stateWithoutTimestamp } = state;\n\n        // Compress common values\n        for (const [key, value] of Object.entries(stateWithoutTimestamp)) {\n            if (Array.isArray(value)) {\n                // Only include non-empty arrays\n                if (value.length > 0) {\n                    compressed[key] = value;\n                }\n            } else if (typeof value === 'object' && value !== null) {\n                // Only include objects with properties\n                if (Object.keys(value).length > 0) {\n                    compressed[key] = value;\n                }\n            } else if (value !== null && value !== undefined && value !== '') {\n                compressed[key] = value;\n            }\n        }\n\n        return compressed;\n    }\n\n    /**\n     * Decompress state from compressed format\n     */\n    decompressState(compressedData) {\n        try {\n            // Simple decompression - in a full implementation,\n            // you might use actual compression algorithms\n            const decoded = atob(compressedData);\n            return JSON.parse(decoded);\n        } catch (error) {\n            console.error('Failed to decompress state:', error);\n            return {};\n        }\n    }\n\n    /**\n     * Check if string is base64 encoded\n     */\n    isBase64(str) {\n        try {\n            return btoa(atob(str)) === str;\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * Generate shareable URL with current state\n     */\n    generateShareableUrl(options = {}) {\n        const {\n            includeView = true,\n            includeFilters = true,\n            includeSearch = true,\n            includeSelection = true,\n            includeExploration = false\n        } = options;\n\n        const currentState = this.parseUrlHash();\n        const shareState = {};\n\n        // Include version for compatibility\n        shareState.v = this.stateVersion;\n\n        // Conditionally include state components\n        if (includeFilters && currentState[this.stateKeys.filters]) {\n            shareState[this.stateKeys.filters] = currentState[this.stateKeys.filters];\n        }\n\n        if (includeSearch && currentState[this.stateKeys.search]) {\n            shareState[this.stateKeys.search] = currentState[this.stateKeys.search];\n        }\n\n        if (includeSelection) {\n            if (currentState[this.stateKeys.selectedNode]) {\n                shareState[this.stateKeys.selectedNode] = currentState[this.stateKeys.selectedNode];\n            }\n            if (currentState[this.stateKeys.selectedEdge]) {\n                shareState[this.stateKeys.selectedEdge] = currentState[this.stateKeys.selectedEdge];\n            }\n        }\n\n        if (includeView) {\n            if (currentState[this.stateKeys.graphView]) {\n                shareState[this.stateKeys.graphView] = currentState[this.stateKeys.graphView];\n            }\n            if (currentState[this.stateKeys.layout]) {\n                shareState[this.stateKeys.layout] = currentState[this.stateKeys.layout];\n            }\n            if (currentState[this.stateKeys.theme]) {\n                shareState[this.stateKeys.theme] = currentState[this.stateKeys.theme];\n            }\n        }\n\n        if (includeExploration && currentState[this.stateKeys.exploredNodes]) {\n            shareState[this.stateKeys.exploredNodes] = currentState[this.stateKeys.exploredNodes];\n        }\n\n        shareState[this.stateKeys.timestamp] = Date.now();\n\n        const hash = this.buildUrlHash(shareState);\n        const baseUrl = `${window.location.protocol}//${window.location.host}${window.location.pathname}`;\n\n        return hash ? `${baseUrl}#${hash}` : baseUrl;\n    }\n\n    /**\n     * Copy shareable URL to clipboard\n     */\n    async copyShareableUrl(options = {}) {\n        try {\n            const url = this.generateShareableUrl(options);\n\n            if (navigator.clipboard && window.isSecureContext) {\n                await navigator.clipboard.writeText(url);\n            } else {\n                // Fallback for older browsers or non-HTTPS\n                const textArea = document.createElement('textarea');\n                textArea.value = url;\n                document.body.appendChild(textArea);\n                textArea.select();\n                document.execCommand('copy');\n                document.body.removeChild(textArea);\n            }\n\n            console.log('📋 Shareable URL copied to clipboard:', url);\n\n            // Emit event for UI feedback\n            document.dispatchEvent(new CustomEvent('urlCopied', {\n                detail: { url, options }\n            }));\n\n            return url;\n        } catch (error) {\n            console.error('Failed to copy URL to clipboard:', error);\n            throw error;\n        }\n    }\n\n    /**\n     * Clear all URL state\n     */\n    clearUrlState() {\n        window.history.replaceState(null, '', window.location.pathname);\n        console.log('🧹 URL state cleared');\n    }\n\n    /**\n     * Get current state summary for debugging\n     */\n    getStateSummary() {\n        const urlState = this.parseUrlHash();\n        const appState = this.convertToAppState(urlState);\n\n        return {\n            urlHash: window.location.hash,\n            urlState,\n            appState,\n            urlLength: window.location.href.length,\n            compressed: window.location.hash.startsWith('#c:')\n        };\n    }\n\n    /**\n     * Validate URL state compatibility\n     */\n    validateState(state) {\n        const issues = [];\n\n        // Check for version compatibility\n        if (state.v && state.v !== this.stateVersion) {\n            issues.push(`State version mismatch: ${state.v} vs ${this.stateVersion}`);\n        }\n\n        // Check for unknown state keys\n        const knownKeys = new Set(Object.values(this.stateKeys));\n        for (const key of Object.keys(state)) {\n            if (!knownKeys.has(key) && key !== 'v') {\n                issues.push(`Unknown state key: ${key}`);\n            }\n        }\n\n        return {\n            valid: issues.length === 0,\n            issues\n        };\n    }\n\n    /**\n     * Restore state from external source\n     */\n    restoreState(state) {\n        const validation = this.validateState(state);\n\n        if (!validation.valid) {\n            console.warn('State validation issues:', validation.issues);\n        }\n\n        this.applyStateToApp(this.convertToAppState(state));\n\n        // Update URL to reflect restored state\n        const hash = this.buildUrlHash(state);\n        this.setUrlHash(hash);\n    }\n\n    /**\n     * Save current state to localStorage for persistence\n     */\n    saveStateToStorage(key = 'app-state-backup') {\n        try {\n            const currentState = this.parseUrlHash();\n            localStorage.setItem(key, JSON.stringify({\n                state: currentState,\n                timestamp: Date.now(),\n                url: window.location.href\n            }));\n\n            console.log('💾 State saved to localStorage');\n        } catch (error) {\n            console.error('Failed to save state to localStorage:', error);\n        }\n    }\n\n    /**\n     * Load state from localStorage\n     */\n    loadStateFromStorage(key = 'app-state-backup') {\n        try {\n            const saved = localStorage.getItem(key);\n            if (!saved) {return null;}\n\n            const { state, timestamp, url } = JSON.parse(saved);\n\n            console.log('📥 Loading state from localStorage:', { timestamp, url });\n\n            return state;\n        } catch (error) {\n            console.error('Failed to load state from localStorage:', error);\n            return null;\n        }\n    }\n\n    /**\n     * Get URL state analytics\n     */\n    getAnalytics() {\n        const currentState = this.parseUrlHash();\n        const appState = this.convertToAppState(currentState);\n\n        return {\n            stateKeys: Object.keys(appState),\n            urlLength: window.location.href.length,\n            stateSize: JSON.stringify(currentState).length,\n            isCompressed: window.location.hash.startsWith('#c:'),\n            timestamp: appState.timestamp,\n            hasFilters: !!appState.filters,\n            hasSearch: !!appState.search,\n            hasSelection: !!(appState.selectedNode || appState.selectedEdge),\n            hasView: !!appState.graphView,\n            hasExploration: !!appState.exploredNodes\n        };\n    }\n\n    /**\n     * Destroy the URL state manager\n     */\n    destroy() {\n        if (this.updateTimeout) {\n            clearTimeout(this.updateTimeout);\n        }\n\n        // Remove event listeners\n        window.removeEventListener('popstate', this.loadStateFromUrl);\n        window.removeEventListener('hashchange', this.loadStateFromUrl);\n\n        console.log('🗑️ URL State Manager destroyed');\n    }\n}\n\nexport default URLStateManager;\n"],"names":["search","constructor","this","searchIndex","Map","lastQuery","searchHistory","maxHistorySize","buildIndex","nodes","edges","clear","forEach","node","searchableText","extractSearchableText","set","id","type","text","data","edge","item","texts","label","push","toLowerCase","String","properties","Object","entries","key","value","join","textSearch","query","options","caseSensitive","exactMatch","searchNodes","searchEdges","limit","searchQuery","results","matches","includes","fuzzyMatch","score","calculateRelevanceScore","length","sort","a","b","addToHistory","criteria","store","getState","filter","matchesCriteria","findNodesByType","nodeType","findConnectedNodes","nodeId","maxDepth","direction","visited","Set","result","queue","depth","shift","has","add","find","n","getNodeConnections","connectedId","findPath","sourceId","targetId","weighted","path","connections","advancedSearch","filters","nodeTypes","edgeTypes","dateRange","minConnections","maxConnections","textResults","r","map","state","keys","matchesProperties","connectionCount","getNodeConnectionCount","getSuggestions","partialQuery","suggestions","split","word","startsWith","Array","from","slice","getSearchHistory","reverse","clearSearchHistory","matchesCriterion","isArray","propertyFilters","propKey","propValue","hasOwnProperty","itemValue","operator","matchesOperator","filterValue","endsWith","RegExp","test","source","target","queryIndex","i","Math","max","existingIndex","indexOf","splice","unshift","searchNeighborhood","connectedNodes","saveSearch","name","savedSearches","getSavedSearches","created","Date","toISOString","lastUsed","localStorage","setItem","JSON","stringify","parse","getItem","executeSavedSearch","Error","updateIndex","throttle","func","wait","inThrottle","args","apply","setTimeout","cancellableDebounce","immediate","timeout","debounced","callNow","clearTimeout","cancel","frameDebounce","frameId","cancelAnimationFrame","requestAnimationFrame","batchDebounce","batchSize","batch","items","subscribe","activeFilters","filterHistory","applyFilters","filterConfig","filteredNodes","filteredEdges","filterNodes","filterEdges","cascadeEdges","nodeIds","nodeMatchesCriteria","edgeMatchesCriteria","filterType","applyNodeFilter","applyEdgeFilter","filterByType","filterByText","filterById","filterByProperties","filterByConnectionCount","filterByDegree","filterByCustomFunction","itemType","applyOperator","itemText","searchValue","itemId","itemProperties","propFilter","inDegree","outDegree","totalDegree","degreeValue","filterFunction","createFilterSet","config","active","action","updateFilterSet","get","updated","applyAllActiveFilters","removeFilterSet","filterSet","delete","toggleFilterSet","newActiveState","getActiveFilters","getAllFilters","allFilters","clearAllFilters","createNodeTypeFilter","createConnectionFilter","connectionFilter","createPropertyFilter","propertyName","propertyValue","createTextFilter","searchText","field","createFilterFromSearch","searchResults","edgeIds","e","exportFilters","importFilters","filtersJson","imported","count","error","getFilterStats","filtered","original","reduction","nodesPercent","toFixed","edgesPercent","timestamp","getFilterHistory","clearFilterHistory","URLStateManager","stateVersion","maxUrlLength","compressionEnabled","debounceDelay","updateTimeout","stateKeys","selectedNode","selectedEdge","graphView","sidePanel","theme","layout","exploredNodes","pathfinding","dataSource","reverseStateKeys","fromEntries","init","loadStateFromUrl","setupEventListeners","setupStoreSubscriptions","window","addEventListener","appState","restoreState","document","updateUrlState","detail","filterState","scope","zoom","center","visible","activeTab","updateFn","setUrlState","currentState","parseUrlHash","now","newHash","buildUrlHash","compressedState","compressState","compressedHash","setUrlHash","pushStateToHistory","urlState","convertToAppState","applyStateToApp","hash","location","substring","decompressState","isBase64","decoded","atob","params","URLSearchParams","decodeURIComponent","json","base64","btoa","serialized","toString","newUrl","pathname","history","replaceState","title","href","shortKey","fullKey","dispatchEvent","CustomEvent","setState","findNodeById","compressed","ts","stateWithoutTimestamp","compressedData","str","generateShareableUrl","includeView","includeFilters","includeSearch","includeSelection","includeExploration","shareState","v","baseUrl","protocol","host","copyShareableUrl","url","navigator","clipboard","isSecureContext","writeText","textArea","createElement","body","appendChild","select","execCommand","removeChild","clearUrlState","getStateSummary","urlHash","urlLength","validateState","issues","knownKeys","values","valid","saveStateToStorage","loadStateFromStorage","saved","getAnalytics","stateSize","isCompressed","hasFilters","hasSearch","hasSelection","hasView","hasExploration","destroy","removeEventListener"],"mappings":"wCA0gBY,MAACA,EAAS,IApgBf,MACH,WAAAC,GACIC,KAAKC,YAAc,IAAIC,IACvBF,KAAKG,UAAY,GACjBH,KAAKI,cAAgB,GACrBJ,KAAKK,eAAiB,EAC1B,CAKA,UAAAC,CAAWC,EAAOC,GACdR,KAAKC,YAAYQ,QAGjBF,EAAMG,QAAQC,IACV,MAAMC,EAAiBZ,KAAKa,sBAAsBF,GAClDX,KAAKC,YAAYa,IAAI,QAAQH,EAAKI,KAAM,CACpCA,GAAIJ,EAAKI,GACTC,KAAM,OACNC,KAAML,EACNM,KAAMP,MAKdH,EAAME,QAAQS,IACV,MAAMP,EAAiBZ,KAAKa,sBAAsBM,GAClDnB,KAAKC,YAAYa,IAAI,QAAQK,EAAKJ,KAAM,CACpCA,GAAII,EAAKJ,GACTC,KAAM,OACNC,KAAML,EACNM,KAAMC,KAGlB,CAKA,qBAAAN,CAAsBO,GAClB,MAAMC,EAAQ,GAed,OAZID,EAAKE,OAAQD,EAAME,KAAKH,EAAKE,MAAME,eACnCJ,EAAKJ,MAAOK,EAAME,KAAKH,EAAKJ,KAAKQ,eACjCJ,EAAKL,IAAKM,EAAME,KAAKE,OAAOL,EAAKL,IAAIS,eAGrCJ,EAAKM,YACLC,OAAOC,QAAQR,EAAKM,YAAYhB,QAAQ,EAAEmB,EAAKC,MAC3CT,EAAME,KAAKM,EAAIL,eACfH,EAAME,KAAKE,OAAOK,GAAON,iBAI1BH,EAAMU,KAAK,IACtB,CAKA,UAAAC,CAAWC,EAAOC,EAAU,IACxB,MAAMC,cACFA,GAAgB,EAAKC,WACrBA,GAAa,EAAKC,YAClBA,GAAc,EAAIC,YAClBA,GAAc,EAAIC,MAClBA,EAAQ,KACRL,EAEJ,IAAKD,EAAQ,MAAO,GAEpB,MAAMO,EAAcL,EAAgBF,EAAQA,EAAMT,cAC5CiB,EAAU,GA+BhB,OA7BAzC,KAAKC,YAAYS,QAAQ,CAACU,EAAMS,KAC5B,IAAKQ,GAA6B,SAAdjB,EAAKJ,KAAkB,OAC3C,IAAKsB,GAA6B,SAAdlB,EAAKJ,KAAkB,OAE3C,IAAI0B,GAAU,EAgBd,OAbIA,EADAN,EACUhB,EAAKH,KAAK0B,SAASH,GAGnBxC,KAAK4C,WAAWxB,EAAKH,KAAMuB,GAGrCE,GACAD,EAAQlB,KAAK,IACNH,EACHyB,MAAO7C,KAAK8C,wBAAwB1B,EAAKH,KAAMuB,OAInDC,EAAQM,QAAUR,SAAtB,IAIJE,EAAQO,KAAK,CAACC,EAAGC,IAAMA,EAAEL,MAAQI,EAAEJ,OAGnC7C,KAAKmD,aAAalB,GAEXQ,CACX,CAKA,WAAAJ,CAAYe,EAAW,IACnB,MAAM7C,MAAEA,GAAU8C,EAAMC,WAExB,OAAO/C,EAAMgD,OAAO5C,GACTX,KAAKwD,gBAAgB7C,EAAMyC,GAE1C,CAKA,WAAAd,CAAYc,EAAW,IACnB,MAAM5C,MAAEA,GAAU6C,EAAMC,WAExB,OAAO9C,EAAM+C,OAAOpC,GACTnB,KAAKwD,gBAAgBrC,EAAMiC,GAE1C,CAKA,eAAAK,CAAgBC,GACZ,MAAMnD,MAAEA,GAAU8C,EAAMC,WACxB,OAAO/C,EAAMgD,OAAO5C,GAAQA,EAAKK,OAAS0C,EAC9C,CAKA,kBAAAC,CAAmBC,EAAQ1B,EAAU,IACjC,MAAM2B,SAAEA,EAAW,EAACC,UAAEA,EAAY,QAAW5B,GACvC3B,MAAEA,EAAKC,MAAEA,GAAU6C,EAAMC,WAEzBS,EAAU,IAAIC,IACdC,EAAS,GACTC,EAAQ,CAAC,CAAEnD,GAAI6C,EAAQO,MAAO,IAEpC,KAAOD,EAAMnB,OAAS,GAAG,CACrB,MAAMhC,GAAEA,EAAEoD,MAAEA,GAAUD,EAAME,QAE5B,KAAIL,EAAQM,IAAItD,IAAOoD,EAAQN,GAA/B,CAGA,GAFAE,EAAQO,IAAIvD,GAERoD,EAAQ,EAAG,CACX,MAAMxD,EAAOJ,EAAMgE,KAAKC,GAAKA,EAAEzD,KAAOA,GAClCJ,GAAOsD,EAAO1C,KAAKZ,EAC3B,CAEA,GAAIwD,EAAQN,EAAU,CACE7D,KAAKyE,mBAAmB1D,EAAIP,EAAOsD,GAC3CpD,QAAQgE,IACXX,EAAQM,IAAIK,IACbR,EAAM3C,KAAK,CAAER,GAAI2D,EAAaP,MAAOA,EAAQ,KAGzD,CAfmD,CAgBvD,CAEA,OAAOF,CACX,CAKA,QAAAU,CAASC,EAAUC,EAAU3C,EAAU,CAAA,GACnC,MAAM2B,SAAEA,EAAW,GAAEiB,SAAEA,GAAW,GAAU5C,GACtC1B,MAAEA,GAAU6C,EAAMC,WAExB,GAAIsB,IAAaC,EAAW,MAAO,CAACD,GAEpC,MAAMV,EAAQ,CAAC,CAAEnD,GAAI6D,EAAUG,KAAM,CAACH,GAAWT,MAAO,IAClDJ,EAAU,IAAIC,IAEpB,KAAOE,EAAMnB,OAAS,GAAG,CACrB,MAAMhC,GAAEA,EAAEgE,KAAEA,EAAIZ,MAAEA,GAAUD,EAAME,QAElC,GAAIL,EAAQM,IAAItD,IAAOoD,EAAQN,EAAW,SAC1CE,EAAQO,IAAIvD,GAEZ,MAAMiE,EAAchF,KAAKyE,mBAAmB1D,EAAIP,EAAO,QAEvD,IAAK,MAAMkE,KAAeM,EAAa,CACnC,GAAIN,IAAgBG,EAChB,MAAO,IAAIE,EAAML,GAGhBX,EAAQM,IAAIK,IACbR,EAAM3C,KAAK,CACPR,GAAI2D,EACJK,KAAM,IAAIA,EAAML,GAChBP,MAAOA,EAAQ,GAG3B,CACJ,CAEA,OAAO,IACX,CAKA,cAAAc,CAAeC,EAAU,IACrB,MAAMjE,KACFA,EAAO,GAAEkE,UACTA,EAAY,GAAEC,UACdA,EAAY,GAAE1D,WACdA,EAAa,CAAA,EAAE2D,UACfA,EAAY,KAAIC,eAChBA,EAAiB,KAAIC,eACrBA,EAAiB,MACjBL,EAEJ,IAAIzC,EAAU,CAAElC,MAAO,GAAIC,MAAO,IAGlC,GAAIS,EAAM,CACN,MAAMuE,EAAcxF,KAAKgC,WAAWf,GACpCwB,EAAQlC,MAAQiF,EAAYjC,OAAOkC,GAAgB,SAAXA,EAAEzE,MAAiB0E,IAAID,GAAKA,EAAEvE,MACtEuB,EAAQjC,MAAQgF,EAAYjC,OAAOkC,GAAgB,SAAXA,EAAEzE,MAAiB0E,IAAID,GAAKA,EAAEvE,KAC1E,KAAO,CACH,MAAMyE,EAAQtC,EAAMC,WACpBb,EAAQlC,MAAQ,IAAIoF,EAAMpF,OAC1BkC,EAAQjC,MAAQ,IAAImF,EAAMnF,MAC9B,CAuBA,GApBI2E,EAAUpC,OAAS,IACnBN,EAAQlC,MAAQkC,EAAQlC,MAAMgD,OAAO5C,GAAQwE,EAAUxC,SAAShC,EAAKK,QAIrEoE,EAAUrC,OAAS,IACnBN,EAAQjC,MAAQiC,EAAQjC,MAAM+C,OAAOpC,GAAQiE,EAAUzC,SAASxB,EAAKH,QAIrEW,OAAOiE,KAAKlE,GAAYqB,OAAS,IACjCN,EAAQlC,MAAQkC,EAAQlC,MAAMgD,OAAO5C,GACjCX,KAAK6F,kBAAkBlF,EAAMe,IAEjCe,EAAQjC,MAAQiC,EAAQjC,MAAM+C,OAAOpC,GACjCnB,KAAK6F,kBAAkB1E,EAAMO,KAKd,OAAnB4D,GAA8C,OAAnBC,EAAyB,CACpD,MAAM/E,MAAEA,GAAU6C,EAAMC,WACxBb,EAAQlC,MAAQkC,EAAQlC,MAAMgD,OAAO5C,IACjC,MAAMmF,EAAkB9F,KAAK+F,uBAAuBpF,EAAKI,GAAIP,GAC7D,OAA2B,OAAnB8E,GAA2BQ,GAAmBR,KAC3B,OAAnBC,GAA2BO,GAAmBP,IAE9D,CAEA,OAAO9C,CACX,CAKA,cAAAuD,CAAeC,EAAc1D,EAAQ,IACjC,IAAK0D,EAAe,MAAO,GAE3B,MAAMhE,EAAQgE,EAAazE,cACrB0E,EAAc,IAAIlC,IAWxB,OATAhE,KAAKC,YAAYS,QAAQU,IACPA,EAAKH,KAAKkF,MAAM,KACxBzF,QAAQ0F,IACNA,EAAKC,WAAWpE,IAAUmE,EAAKrD,OAASd,EAAMc,QAC9CmD,EAAY5B,IAAI8B,OAKrBE,MAAMC,KAAKL,GAAaM,MAAM,EAAGjE,EAC5C,CAKA,gBAAAkE,GACI,MAAO,IAAIzG,KAAKI,eAAesG,SACnC,CAKA,kBAAAC,GACI3G,KAAKI,cAAgB,EACzB,CAKA,eAAAoD,CAAgBpC,EAAMgC,GAClB,IAAK,MAAOvB,EAAKC,KAAUH,OAAOC,QAAQwB,GACtC,IAAKpD,KAAK4G,iBAAiBxF,EAAMS,EAAKC,GAClC,OAAO,EAGf,OAAO,CACX,CAEA,gBAAA8E,CAAiBxF,EAAMS,EAAKC,GACxB,GAAY,SAARD,EAAgB,CAChB,MAAMjB,EAAiBZ,KAAKa,sBAAsBO,GAClD,OAAOpB,KAAK4C,WAAWhC,EAAgBkB,EAAMN,cACjD,CAEA,MAAY,SAARK,EACOyE,MAAMO,QAAQ/E,GAASA,EAAMa,SAASvB,EAAKJ,MAAQI,EAAKJ,OAASc,EAGhE,OAARD,EACOyE,MAAMO,QAAQ/E,GAASA,EAAMa,SAASvB,EAAKL,IAAMK,EAAKL,KAAOe,EAG5D,eAARD,EACO7B,KAAK6F,kBAAkBzE,EAAMU,GAGjCV,EAAKS,KAASC,CACzB,CAEA,iBAAA+D,CAAkBzE,EAAM0F,GACpB,IAAK1F,EAAKM,WAAa,OAA+C,IAAxCC,OAAOiE,KAAKkB,GAAiB/D,OAE3D,IAAK,MAAOgE,EAASC,KAAcrF,OAAOC,QAAQkF,GAAkB,CAChE,IAAK1F,EAAKM,WAAWuF,eAAeF,GAAW,OAAO,EAEtD,MAAMG,EAAY9F,EAAKM,WAAWqF,GAElC,GAAyB,iBAAdC,GAA0BA,EAAUG,UAC3C,IAAKnH,KAAKoH,gBAAgBF,EAAWF,EAAUlF,MAAOkF,EAAUG,UAC5D,OAAO,OAER,GAAID,IAAcF,EACrB,OAAO,CAEf,CAEA,OAAO,CACX,CAEA,eAAAI,CAAgBF,EAAWG,EAAaF,GACpC,OAAQA,GACR,IAAK,KAUL,QAAS,OAAOD,IAAcG,EAT9B,IAAK,KAAM,OAAOH,IAAcG,EAChC,IAAK,KAAM,OAAOH,EAAYG,EAC9B,IAAK,MAAO,OAAOH,GAAaG,EAChC,IAAK,KAAM,OAAOH,EAAYG,EAC9B,IAAK,MAAO,OAAOH,GAAaG,EAChC,IAAK,WAAY,OAAO5F,OAAOyF,GAAW1F,cAAcmB,SAASlB,OAAO4F,GAAa7F,eACrF,IAAK,aAAc,OAAOC,OAAOyF,GAAW1F,cAAc6E,WAAW5E,OAAO4F,GAAa7F,eACzF,IAAK,WAAY,OAAOC,OAAOyF,GAAW1F,cAAc8F,SAAS7F,OAAO4F,GAAa7F,eACrF,IAAK,QAAS,OAAO,IAAI+F,OAAOF,EAAa,KAAKG,KAAK/F,OAAOyF,IAGlE,CAEA,kBAAAzC,CAAmBb,EAAQpD,EAAOsD,EAAY,QAC1C,MAAMkB,EAAc,GAWpB,OATAxE,EAAME,QAAQS,IACQ,SAAd2C,GAAsC,QAAdA,GACpB3C,EAAKsG,SAAW7D,GAASoB,EAAYzD,KAAKJ,EAAKuG,QAErC,SAAd5D,GAAsC,OAAdA,GACpB3C,EAAKuG,SAAW9D,GAASoB,EAAYzD,KAAKJ,EAAKsG,UAIpDzC,CACX,CAEA,sBAAAe,CAAuBnC,EAAQpD,GAC3B,OAAOA,EAAM+C,OAAOpC,GAChBA,EAAKsG,SAAW7D,GAAUzC,EAAKuG,SAAW9D,GAC5Cb,MACN,CAEA,UAAAH,CAAW3B,EAAMgB,GAEb,IAAI0F,EAAa,EAEjB,IAAK,IAAIC,EAAI,EAAGA,EAAI3G,EAAK8B,QAAU4E,EAAa1F,EAAMc,OAAQ6E,IACtD3G,EAAK2G,KAAO3F,EAAM0F,IAClBA,IAIR,OAAOA,IAAe1F,EAAMc,MAChC,CAEA,uBAAAD,CAAwB7B,EAAMgB,GAC1B,IAAIY,EAAQ,EAGR5B,EAAK0B,SAASV,KAASY,GAAS,KAGhC5B,EAAKoF,WAAWpE,KAASY,GAAS,IAYtC,OATc5B,EAAKkF,MAAM,KACnBzF,QAAQ0F,IACNA,EAAKC,WAAWpE,KAASY,GAAS,IAClCuD,IAASnE,IAAQY,GAAS,MAIlCA,GAAuB,GAAd5B,EAAK8B,OAEP8E,KAAKC,IAAI,EAAGjF,EACvB,CAEA,YAAAM,CAAalB,GACT,IAAKA,GAASA,IAAUjC,KAAKG,UAAY,OAGzC,MAAM4H,EAAgB/H,KAAKI,cAAc4H,QAAQ/F,GAC7C8F,GAAgB,GAChB/H,KAAKI,cAAc6H,OAAOF,EAAe,GAI7C/H,KAAKI,cAAc8H,QAAQjG,GAGvBjC,KAAKI,cAAc2C,OAAS/C,KAAKK,iBACjCL,KAAKI,cAAgBJ,KAAKI,cAAcoG,MAAM,EAAGxG,KAAKK,iBAG1DL,KAAKG,UAAY8B,CACrB,CAKA,kBAAAkG,CAAmBvE,EAAQ3B,EAAOkC,EAAQ,GACtC,MAAMiE,EAAiBpI,KAAK2D,mBAAmBC,EAAQ,CAAEC,SAAUM,IAEnE,OAAKlC,EAEEmG,EAAe7E,OAAO5C,IACzB,MAAMC,EAAiBZ,KAAKa,sBAAsBF,GAClD,OAAOX,KAAK4C,WAAWhC,EAAgBqB,EAAMT,iBAJ7B4G,CAMxB,CAKA,UAAAC,CAAWC,EAAMpD,GACb,MAAMqD,EAAgBvI,KAAKwI,mBAC3BD,EAAcD,GAAQ,CAClBpD,UACAuD,SAAS,IAAIC,MAAOC,cACpBC,UAAU,IAAIF,MAAOC,eAGzBE,aAAaC,QAAQ,oBAAqBC,KAAKC,UAAUT,GAC7D,CAKA,gBAAAC,GACI,IACI,OAAOO,KAAKE,MAAMJ,aAAaK,QAAQ,sBAAwB,KACnE,CAAE,MACE,MAAO,CAAA,CACX,CACJ,CAKA,kBAAAC,CAAmBb,GACf,MAAMC,EAAgBvI,KAAKwI,mBACrB1I,EAASyI,EAAcD,GAE7B,IAAKxI,EAAS,MAAM,IAAIsJ,MAAM,iBAAiBd,gBAM/C,OAHAxI,EAAO8I,UAAW,IAAIF,MAAOC,cAC7BE,aAAaC,QAAQ,oBAAqBC,KAAKC,UAAUT,IAElDvI,KAAKiF,eAAenF,EAAOoF,QACtC,CAKA,WAAAmE,GACI,MAAM9I,MAAEA,EAAKC,MAAEA,GAAU6C,EAAMC,WAC/BtD,KAAKM,WAAWC,EAAOC,EAC3B,GCxeG,SAAS8I,EAASC,EAAMC,GAC3B,IAAIC,EAEJ,OAAO,YAAYC,GACVD,IACDF,EAAKI,MAAM3J,KAAM0J,GACjBD,GAAa,EAEbG,WAAW,KACPH,GAAa,GACdD,GAEX,CACJ,CAKO,SAASK,EAAoBN,EAAMC,EAAMM,GAAY,GACxD,IAAIC,EAEJ,MAAMC,EAAY,YAA6BN,GAC3C,MAKMO,EAAUH,IAAcC,EAE9BG,aAAaH,GACbA,EAAUH,WARI,KACVG,EAAU,KACLD,GAAYP,EAAKI,MAAM3J,KAAM0J,IAMVF,GAExBS,GAAUV,EAAKI,MAAM3J,KAAM0J,EACnC,EAOA,OALAM,EAAUG,OAAS,KACfD,aAAaH,GACbA,EAAU,MAGPC,CACX,CA8HO,SAASI,EAAcb,GAC1B,IAAIc,EAEJ,OAAO,YAAYX,GACXW,GACAC,qBAAqBD,GAGzBA,EAAUE,sBAAsB,KAC5BhB,EAAKI,MAAM3J,KAAM0J,IAEzB,CACJ,CAkDO,SAASc,EAAcjB,EAAMC,EAAO,IAAKiB,EAAY,IACxD,IACIV,EADAW,EAAQ,GAGZ,OAAO,SAAStJ,GAGZ,GAFAsJ,EAAMnJ,KAAKH,GAEPsJ,EAAM3H,QAAU0H,EAAW,CAE3B,MAAME,EAAQD,EAAMlE,QACpBkE,EAAQ,GACRR,aAAaH,GACbR,EAAKoB,EACT,MAEIT,aAAaH,GACbA,EAAUH,WAAW,KACjB,GAAIc,EAAM3H,OAAS,EAAG,CAClB,MAAM4H,EAAQD,EAAMlE,QACpBkE,EAAQ,GACRnB,EAAKoB,EACT,GACDnB,EAEX,CACJ,CDiPAnG,EAAMuH,UAAU,QAAS,IAAM9K,EAAOuJ,eACtChG,EAAMuH,UAAU,QAAS,IAAM9K,EAAOuJ,eE+I1B,MAAC9F,EAAS,IAvpBf,MACH,WAAAxD,GACIC,KAAK6K,cAAgB,IAAI3K,IACzBF,KAAK8K,cAAgB,GACrB9K,KAAKK,eAAiB,EAC1B,CAKA,YAAA0K,CAAaC,EAAe,IACxB,MAAMzK,MAAEA,EAAKC,MAAEA,GAAU6C,EAAMC,WAE/B,IAAI2H,EAAgB,IAAI1K,GACpB2K,EAAgB,IAAI1K,GAaxB,GAVIwK,EAAazK,QACb0K,EAAgBjL,KAAKmL,YAAYF,EAAeD,EAAazK,QAI7DyK,EAAaxK,QACb0K,EAAgBlL,KAAKoL,YAAYF,EAAeF,EAAaxK,SAI/B,IAA9BwK,EAAaK,aAAwB,CACrC,MAAMC,EAAU,IAAItH,IAAIiH,EAAcvF,IAAIlB,GAAKA,EAAEzD,KACjDmK,EAAgBA,EAAc3H,OAAOpC,GACjCmK,EAAQjH,IAAIlD,EAAKsG,SAAW6D,EAAQjH,IAAIlD,EAAKuG,QAErD,CAEA,MAAO,CAAEnH,MAAO0K,EAAezK,MAAO0K,EAC1C,CAKA,WAAAC,CAAY5K,EAAO6C,GACf,OAAO7C,EAAMgD,OAAO5C,GAAQX,KAAKuL,oBAAoB5K,EAAMyC,GAC/D,CAKA,WAAAgI,CAAY5K,EAAO4C,GACf,OAAO5C,EAAM+C,OAAOpC,GAAQnB,KAAKwL,oBAAoBrK,EAAMiC,GAC/D,CAKA,mBAAAmI,CAAoB5K,EAAMyC,GACtB,IAAK,MAAOqI,EAAYpE,KAAgB1F,OAAOC,QAAQwB,GACnD,IAAKpD,KAAK0L,gBAAgB/K,EAAM8K,EAAYpE,GACxC,OAAO,EAGf,OAAO,CACX,CAKA,mBAAAmE,CAAoBrK,EAAMiC,GACtB,IAAK,MAAOqI,EAAYpE,KAAgB1F,OAAOC,QAAQwB,GACnD,IAAKpD,KAAK2L,gBAAgBxK,EAAMsK,EAAYpE,GACxC,OAAO,EAGf,OAAO,CACX,CAKA,eAAAqE,CAAgB/K,EAAM8K,EAAYpE,GAC9B,OAAQoE,GACR,IAAK,OACD,OAAOzL,KAAK4L,aAAajL,EAAKK,KAAMqG,GAExC,IAAK,QACD,OAAOrH,KAAK6L,aAAalL,EAAKW,MAAO+F,GAEzC,IAAK,KACD,OAAOrH,KAAK8L,WAAWnL,EAAKI,GAAIsG,GAEpC,IAAK,aACD,OAAOrH,KAAK+L,mBAAmBpL,EAAKe,YAAc,CAAA,EAAI2F,GAE1D,IAAK,cACD,OAAOrH,KAAKgM,wBAAwBrL,EAAKI,GAAIsG,GAEjD,IAAK,SACD,OAAOrH,KAAKiM,eAAetL,EAAKI,GAAIsG,GAExC,IAAK,SACD,OAAOrH,KAAKkM,uBAAuBvL,EAAM0G,GAE7C,QACI,OAAO,EAEf,CAKA,eAAAsE,CAAgBxK,EAAMsK,EAAYpE,GAC9B,OAAQoE,GACR,IAAK,OACD,OAAOzL,KAAK4L,aAAazK,EAAKH,KAAMqG,GAExC,IAAK,QACD,OAAOrH,KAAK6L,aAAa1K,EAAKG,MAAO+F,GAEzC,IAAK,KACD,OAAOrH,KAAK8L,WAAW3K,EAAKJ,GAAIsG,GAEpC,IAAK,aACD,OAAOrH,KAAK+L,mBAAmB5K,EAAKO,YAAc,CAAA,EAAI2F,GAE1D,IAAK,SACD,OAAOrH,KAAK8L,WAAW3K,EAAKsG,OAAQJ,GAExC,IAAK,SACD,OAAOrH,KAAK8L,WAAW3K,EAAKuG,OAAQL,GAExC,IAAK,SACD,OAAOrH,KAAKkM,uBAAuB/K,EAAMkG,GAE7C,QACI,OAAO,EAEf,CAKA,YAAAuE,CAAaO,EAAU9E,GACnB,OAAIf,MAAMO,QAAQQ,GACPA,EAAY1E,SAASwJ,GAEL,iBAAhB9E,GAA4BA,EAAYF,SACxCnH,KAAKoM,cAAcD,EAAU9E,EAAYvF,MAAOuF,EAAYF,UAEhEgF,IAAa9E,CACxB,CAKA,YAAAwE,CAAaQ,EAAUhF,GACnB,IAAKgF,EAAW,OAAQhF,EAExB,GAA2B,iBAAhBA,EACP,OAAOgF,EAAS7K,cAAcmB,SAAS0E,EAAY7F,eAGvD,GAA2B,iBAAhB6F,EAA0B,CACjC,MAAMvF,MAAEA,EAAKqF,SAAEA,EAAW,WAAUhF,cAAEA,GAAgB,GAAUkF,EAC1DpG,EAAOkB,EAAgBkK,EAAWA,EAAS7K,cAC3C8K,EAAcnK,EAAgBL,EAAQA,EAAMN,cAElD,OAAQ2F,GACR,IAAK,SACD,OAAOlG,IAASqL,EACpB,IAAK,WAQL,QACI,OAAOrL,EAAK0B,SAAS2J,GAPzB,IAAK,aACD,OAAOrL,EAAKoF,WAAWiG,GAC3B,IAAK,WACD,OAAOrL,EAAKqG,SAASgF,GACzB,IAAK,QACD,OAAO,IAAI/E,OAAOzF,EAAOK,EAAgB,IAAM,MAAMqF,KAAK6E,GAIlE,CAEA,OAAO,CACX,CAKA,UAAAP,CAAWS,EAAQlF,GACf,OAAIf,MAAMO,QAAQQ,GACPA,EAAY1E,SAAS4J,GAEL,iBAAhBlF,GAA4BA,EAAYF,SACxCnH,KAAKoM,cAAcG,EAAQlF,EAAYvF,MAAOuF,EAAYF,UAE9DoF,IAAWlF,CACtB,CAKA,kBAAA0E,CAAmBS,EAAgBnF,GAC/B,GAA2B,iBAAhBA,EAA2B,OAAO,EAE7C,IAAK,MAAON,EAAS0F,KAAe9K,OAAOC,QAAQyF,GAAc,CAC7D,IAAKmF,EAAevF,eAAeF,GAC/B,OAAO,EAGX,MAAMC,EAAYwF,EAAezF,GAEjC,GAA0B,iBAAf0F,GAA2BA,EAAWtF,UAC7C,IAAKnH,KAAKoM,cAAcpF,EAAWyF,EAAW3K,MAAO2K,EAAWtF,UAC5D,OAAO,OAGX,GAAIH,IAAcyF,EACd,OAAO,CAGnB,CAEA,OAAO,CACX,CAKA,uBAAAT,CAAwBpI,EAAQyD,GAC5B,MAAM7G,MAAEA,GAAU6C,EAAMC,WAClBwC,EAAkBtF,EAAM+C,OAAOpC,GACjCA,EAAKsG,SAAW7D,GAAUzC,EAAKuG,SAAW9D,GAC5Cb,OAEF,MAA2B,iBAAhBsE,EACAvB,IAAoBuB,EAGJ,iBAAhBA,GACArH,KAAKoM,cAActG,EAAiBuB,EAAYvF,MAAOuF,EAAYF,SAIlF,CAKA,cAAA8E,CAAerI,EAAQyD,GACnB,MAAM7G,MAAEA,GAAU6C,EAAMC,WAElBoJ,EAAWlM,EAAM+C,OAAOpC,GAAQA,EAAKuG,SAAW9D,GAAQb,OACxD4J,EAAYnM,EAAM+C,OAAOpC,GAAQA,EAAKsG,SAAW7D,GAAQb,OACzD6J,EAAcF,EAAWC,GAEzB3L,KAAEA,EAAO,QAAOmG,SAAEA,EAAW,KAAIrF,MAAEA,GAAUuF,EAEnD,IAAIwF,EACJ,OAAQ7L,GACR,IAAK,KACD6L,EAAcH,EACd,MACJ,IAAK,MACDG,EAAcF,EACd,MAEJ,QACIE,EAAcD,EAIlB,OAAO5M,KAAKoM,cAAcS,EAAa/K,EAAOqF,EAClD,CAKA,sBAAA+E,CAAuB9K,EAAM0L,GACzB,MAA8B,mBAAnBA,GACJA,EAAe1L,EAC1B,CAKA,aAAAgL,CAAclF,EAAWG,EAAaF,GAClC,OAAQA,GACR,IAAK,KACL,IAAK,IACL,IAAK,KA+CL,QACI,OAAOD,IAAcG,EA7CzB,IAAK,KACL,IAAK,KACD,OAAOH,IAAcG,EAEzB,IAAK,KACL,IAAK,IACD,OAAOH,EAAYG,EAEvB,IAAK,MACL,IAAK,KACD,OAAOH,GAAaG,EAExB,IAAK,KACL,IAAK,IACD,OAAOH,EAAYG,EAEvB,IAAK,MACL,IAAK,KACD,OAAOH,GAAaG,EAExB,IAAK,KACD,OAAOf,MAAMO,QAAQQ,IAAgBA,EAAY1E,SAASuE,GAE9D,IAAK,MACD,OAAOZ,MAAMO,QAAQQ,KAAiBA,EAAY1E,SAASuE,GAE/D,IAAK,UACD,OAAOZ,MAAMO,QAAQQ,IACa,IAAvBA,EAAYtE,QACZmE,GAAaG,EAAY,IACzBH,GAAaG,EAAY,GAExC,IAAK,WACD,OAAO5F,OAAOyF,GAAW1F,cAAcmB,SAASlB,OAAO4F,GAAa7F,eAExE,IAAK,aACD,OAAOC,OAAOyF,GAAW1F,cAAc6E,WAAW5E,OAAO4F,GAAa7F,eAE1E,IAAK,WACD,OAAOC,OAAOyF,GAAW1F,cAAc8F,SAAS7F,OAAO4F,GAAa7F,eAExE,IAAK,QACD,OAAO,IAAI+F,OAAOF,EAAa,KAAKG,KAAK/F,OAAOyF,IAKxD,CAKA,eAAA6F,CAAgBzE,EAAM0E,GAQlB,OAPAhN,KAAK6K,cAAc/J,IAAIwH,EAAM,CACzB0E,SACAvE,SAAS,IAAIC,MAAOC,cACpBsE,QAAQ,IAGZjN,KAAKmD,aAAa,CAAEmF,OAAM0E,SAAQE,OAAQ,WACnClN,KAAK+K,aAAaiC,EAC7B,CAKA,eAAAG,CAAgB7E,EAAM0E,GAClB,IAAKhN,KAAK6K,cAAcxG,IAAIiE,GACxB,MAAM,IAAIc,MAAM,eAAed,gBAUnC,OAPAtI,KAAK6K,cAAc/J,IAAIwH,EAAM,IACtBtI,KAAK6K,cAAcuC,IAAI9E,GAC1B0E,SACAK,SAAS,IAAI3E,MAAOC,gBAGxB3I,KAAKmD,aAAa,CAAEmF,OAAM0E,SAAQE,OAAQ,WACnClN,KAAKsN,uBAChB,CAKA,eAAAC,CAAgBjF,GACZ,GAAItI,KAAK6K,cAAcxG,IAAIiE,GAAO,CAC9B,MAAMkF,EAAYxN,KAAK6K,cAAcuC,IAAI9E,GACzCtI,KAAK6K,cAAc4C,OAAOnF,GAC1BtI,KAAKmD,aAAa,CAAEmF,OAAM0E,OAAQQ,EAAUR,OAAQE,OAAQ,UAChE,CAEA,OAAOlN,KAAKsN,uBAChB,CAKA,eAAAI,CAAgBpF,EAAM2E,EAAS,MAC3B,IAAKjN,KAAK6K,cAAcxG,IAAIiE,GAAQ,OAAO,KAE3C,MAAMkF,EAAYxN,KAAK6K,cAAcuC,IAAI9E,GACnCqF,EAA4B,OAAXV,EAAkBA,GAAUO,EAAUP,OAQ7D,OANAjN,KAAK6K,cAAc/J,IAAIwH,EAAM,IACtBkF,EACHP,OAAQU,IAGZ3N,KAAKmD,aAAa,CAAEmF,OAAM0E,OAAQQ,EAAUR,OAAQE,OAAQS,EAAiB,WAAa,eACnF3N,KAAKsN,uBAChB,CAKA,qBAAAA,GACI,MAAM/M,MAAEA,EAAKC,MAAEA,GAAU6C,EAAMC,WAC/B,IAAIW,EAAS,CAAE1D,MAAO,IAAIA,GAAQC,MAAO,IAAIA,IAE7C,IAAK,MAAO8H,EAAMkF,KAAcxN,KAAK6K,cAAcjJ,UAC3C4L,EAAUP,SACVhJ,EAASjE,KAAK+K,aAAa,IACpByC,EAAUR,OACbzM,MAAO0D,EAAO1D,MACdC,MAAOyD,EAAOzD,SAK1B,OAAOyD,CACX,CAKA,gBAAA2J,GACI,MAAM/C,EAAgB,CAAA,EAMtB,OALA7K,KAAK6K,cAAcnK,QAAQ,CAAC8M,EAAWlF,KAC/BkF,EAAUP,SACVpC,EAAcvC,GAAQkF,KAGvB3C,CACX,CAKA,aAAAgD,GACI,MAAMC,EAAa,CAAA,EAInB,OAHA9N,KAAK6K,cAAcnK,QAAQ,CAAC8M,EAAWlF,KACnCwF,EAAWxF,GAAQkF,IAEhBM,CACX,CAKA,eAAAC,GACI/N,KAAK6K,cAAcpK,QACnBT,KAAKmD,aAAa,CAAE+J,OAAQ,cAE5B,MAAM3M,MAAEA,EAAKC,MAAEA,GAAU6C,EAAMC,WAC/B,MAAO,CAAE/C,QAAOC,QACpB,CAKA,oBAAAwN,CAAqB7I,GACjB,OAAOnF,KAAK+M,gBAAgB,WAAY,CACpCxM,MAAO,CAAES,KAAMmE,IAEvB,CAEA,sBAAA8I,CAAuB3I,EAAiB,EAAGC,EAAiB,MACxD,MAAM2I,EAAmB,CAAE/G,SAAU,MAAOrF,MAAOwD,GAMnD,OALuB,OAAnBC,IACA2I,EAAiB/G,SAAW,UAC5B+G,EAAiBpM,MAAQ,CAACwD,EAAgBC,IAGvCvF,KAAK+M,gBAAgB,cAAe,CACvCxM,MAAO,CAAEyE,YAAakJ,IAE9B,CAEA,oBAAAC,CAAqBC,EAAcC,EAAelH,EAAW,MACzD,OAAOnH,KAAK+M,gBAAgB,YAAYqB,IAAgB,CACpD7N,MAAO,CACHmB,WAAY,CACR0M,CAACA,GAAe,CAAEjH,WAAUrF,MAAOuM,MAInD,CAEA,gBAAAC,CAAiBC,EAAYC,EAAQ,SACjC,OAAOxO,KAAK+M,gBAAgB,aAAc,CACtCxM,MAAO,CACHiO,CAACA,GAAQ,CAAE1M,MAAOyM,EAAYpH,SAAU,cAGpD,CAKA,sBAAAsH,CAAuBC,EAAepG,EAAO,gBACzC,MAAMgD,EAAUoD,EAAcnO,MAAMmF,IAAIlB,GAAKA,EAAEzD,IACzC4N,EAAUD,EAAclO,MAAMkF,IAAIkJ,GAAKA,EAAE7N,IAE/C,OAAOf,KAAK+M,gBAAgBzE,EAAM,CAC9B/H,MAAO,CAAEQ,GAAIuK,GACb9K,MAAO,CAAEO,GAAI4N,IAErB,CAKA,aAAAE,GACI,MAAM3J,EAAU,CAAA,EAShB,OARAlF,KAAK6K,cAAcnK,QAAQ,CAAC8M,EAAWlF,KACnCpD,EAAQoD,GAAQ,CACZ0E,OAAQQ,EAAUR,OAClBC,OAAQO,EAAUP,OAClBxE,QAAS+E,EAAU/E,QACnB4E,QAASG,EAAUH,WAGpBtE,KAAKC,UAAU9D,EAAS,KAAM,EACzC,CAKA,aAAA4J,CAAcC,GACV,IACI,MAAM7J,EAAU6D,KAAKE,MAAM8F,GAa3B,OAXApN,OAAOC,QAAQsD,GAASxE,QAAQ,EAAE4H,EAAMkF,MACpCxN,KAAK6K,cAAc/J,IAAIwH,EAAM,CACzB0E,OAAQQ,EAAUR,OAClBC,QAA6B,IAArBO,EAAUP,OAClBxE,QAAS+E,EAAU/E,UAAW,IAAIC,MAAOC,cACzC0E,QAASG,EAAUH,QACnB2B,UAAU,IAAItG,MAAOC,kBAI7B3I,KAAKmD,aAAa,CAAE+J,OAAQ,SAAU+B,MAAOtN,OAAOiE,KAAKV,GAASnC,SAC3D/C,KAAKsN,uBAChB,CAAE,MAAO4B,GACL,MAAM,IAAI9F,MAAM,oCACpB,CACJ,CAKA,cAAA+F,GACI,MAAM5O,MAAEA,EAAKC,MAAEA,GAAU6C,EAAMC,WACzB8L,EAAWpP,KAAKsN,wBAEtB,MAAO,CACH+B,SAAU,CACN9O,MAAOA,EAAMwC,OACbvC,MAAOA,EAAMuC,QAEjBqM,SAAU,CACN7O,MAAO6O,EAAS7O,MAAMwC,OACtBvC,MAAO4O,EAAS5O,MAAMuC,QAE1BuM,UAAW,CACP/O,MAAOA,EAAMwC,OAASqM,EAAS7O,MAAMwC,OACrCvC,MAAOA,EAAMuC,OAASqM,EAAS5O,MAAMuC,OACrCwM,aAAchP,EAAMwC,OAAS,GAAkD,KAA5C,EAAIqM,EAAS7O,MAAMwC,OAASxC,EAAMwC,SAAeyM,QAAQ,GAAK,EACjGC,aAAcjP,EAAMuC,OAAS,GAAkD,KAA5C,EAAIqM,EAAS5O,MAAMuC,OAASvC,EAAMuC,SAAeyM,QAAQ,GAAK,GAErG3E,cAAevE,MAAMC,KAAKvG,KAAK6K,cAAcjF,QAAQrC,OAAO+E,GACxDtI,KAAK6K,cAAcuC,IAAI9E,GAAM2E,QAC/BlK,OAEV,CAKA,YAAAI,CAAa+J,GACTlN,KAAK8K,cAAc5C,QAAQ,IACpBgF,EACHwC,WAAW,IAAIhH,MAAOC,gBAItB3I,KAAK8K,cAAc/H,OAAS/C,KAAKK,iBACjCL,KAAK8K,cAAgB9K,KAAK8K,cAActE,MAAM,EAAGxG,KAAKK,gBAE9D,CAKA,gBAAAsP,GACI,MAAO,IAAI3P,KAAK8K,cACpB,CAKA,kBAAA8E,GACI5P,KAAK8K,cAAgB,EACzB,GC5lBG,MAAM+E,EACT,WAAA9P,GACIC,KAAK8P,aAAe,MACpB9P,KAAK+P,aAAe,KACpB/P,KAAKgQ,oBAAqB,EAC1BhQ,KAAKiQ,cAAgB,IACrBjQ,KAAKkQ,cAAgB,KAErBlQ,KAAKmQ,UAAY,CAEbjL,QAAS,IACTpF,OAAQ,IACRsQ,aAAc,IACdC,aAAc,IAGdC,UAAW,IACXC,UAAW,IACXC,MAAO,IACPC,OAAQ,IAGRC,cAAe,KACfC,YAAa,KAGbC,WAAY,IACZlB,UAAW,MAGf1P,KAAK6Q,iBAAmBlP,OAAOmP,YAC3BnP,OAAOC,QAAQ5B,KAAKmQ,WAAWzK,IAAI,EAAE7D,EAAKC,KAAW,CAACA,EAAOD,KAGjE7B,KAAK+Q,MACT,CAKA,IAAAA,GAEI/Q,KAAKgR,mBAGLhR,KAAKiR,sBAGLjR,KAAKkR,yBAGT,CAKA,mBAAAD,GAEIE,OAAOC,iBAAiB,WAAaxC,IAC7BA,EAAEjJ,OAASiJ,EAAEjJ,MAAM0L,SACnBrR,KAAKsR,aAAa1C,EAAEjJ,MAAM0L,UAE1BrR,KAAKgR,qBAKbG,OAAOC,iBAAiB,aAAc,KAClCpR,KAAKgR,qBAITO,SAASH,iBAAiB,iBAAmBxC,IACzC5O,KAAKwR,eAAe,UAAW5C,EAAE6C,OAAOC,eAI5CH,SAASH,iBAAiB,eAAiBxC,IACvC5O,KAAKwR,eAAe,SAAU,CAC1BvP,MAAO2M,EAAE6C,OAAOxP,MAChB0P,MAAO/C,EAAE6C,OAAOE,MAChBjC,UAAWd,EAAE6C,OAAO/B,cAK5B6B,SAASH,iBAAiB,eAAiBxC,IACvC5O,KAAKwR,eAAe,SAAU5C,EAAE6C,OAAOhB,UAI3Cc,SAASH,iBAAiB,eAAiBxC,IACvC5O,KAAKwR,eAAe,eAAgB5C,EAAE6C,OAAO7N,UAIjD2N,SAASH,iBAAiB,0BAA4BxC,IAClD5O,KAAKwR,eAAe,gBAAiBlL,MAAMC,KAAKqI,EAAE6C,OAAOf,iBAEjE,CAKA,uBAAAQ,GAEI7N,EAAMuH,UAAU,eAAiBjK,IAC7B,MAAMiD,EAASjD,EAAOA,EAAKI,GAAK,KAChCf,KAAKwR,eAAe,eAAgB5N,KAIxCP,EAAMuH,UAAU,YAAc0F,IAC1BtQ,KAAKwR,eAAe,YAAa,CAC7BI,KAAMtB,EAAUsB,KAChBC,OAAQvB,EAAUuB,OAClBpB,OAAQH,EAAUG,WAK1BpN,EAAMuH,UAAU,YAAc2F,IAC1BvQ,KAAKwR,eAAe,YAAa,CAC7BM,QAASvB,EAAUuB,QACnBC,UAAWxB,EAAUwB,aAGjC,CAKA,cAAAP,CAAe3P,EAAKC,EAAOgI,GAAY,GAE/B9J,KAAKkQ,eACLhG,aAAalK,KAAKkQ,eAItB,MAAM8B,EAAW,KACbhS,KAAKiS,YAAYpQ,EAAKC,IAGtBgI,EACAkI,IAEAhS,KAAKkQ,cAAgBtG,WAAWoI,EAAUhS,KAAKiQ,cAEvD,CAKA,WAAAgC,CAAYpQ,EAAKC,GACb,IACI,MAAMoQ,EAAelS,KAAKmS,eAEtBrQ,SACCwE,MAAMO,QAAQ/E,IAA2B,IAAjBA,EAAMiB,QACb,iBAAVjB,GAAoD,IAA9BH,OAAOiE,KAAK9D,GAAOiB,cAC1CmP,EAAalS,KAAKmQ,UAAUtO,IAEnCqQ,EAAalS,KAAKmQ,UAAUtO,IAAQC,EAGxCoQ,EAAalS,KAAKmQ,UAAUT,WAAahH,KAAK0J,MAE9C,MAAMC,EAAUrS,KAAKsS,aAAaJ,GAGlC,GAAIG,EAAQtP,OAAS/C,KAAK+P,aAAc,CAEpC,MAAMwC,EAAkBvS,KAAKwS,cAAcN,GACrCO,EAAiBzS,KAAKsS,aAAaC,GAErCE,EAAe1P,QAAU/C,KAAK+P,cAC9B/P,KAAK0S,WAAWD,EAIxB,MACIzS,KAAK0S,WAAWL,GAIpBrS,KAAK2S,mBAAmBT,EAE5B,CAAE,MAAOhD,GAET,CACJ,CAKA,gBAAA8B,GACI,IACI,MAAM4B,EAAW5S,KAAKmS,eAChBd,EAAWrR,KAAK6S,kBAAkBD,GAEpCjR,OAAOiE,KAAKyL,GAAUtO,OAAS,GAC/B/C,KAAK8S,gBAAgBzB,EAG7B,CAAE,MAAOnC,GAET,CACJ,CAKA,YAAAiD,GACI,MAAMY,EAAO5B,OAAO6B,SAASD,KAAKE,UAAU,GAC5C,IAAKF,EAAO,MAAO,GAEnB,IAEI,GAAIA,EAAK1M,WAAW,MAChB,OAAOrG,KAAKkT,gBAAgBH,EAAKE,UAAU,IAI/C,GAAIjT,KAAKmT,SAASJ,GAAO,CACrB,MAAMK,EAAUC,KAAKN,GACrB,OAAOhK,KAAKE,MAAMmK,EACtB,CAGA,MAAME,EAAS,IAAIC,gBAAgBR,GAC7BpN,EAAQ,CAAA,EAEd,IAAK,MAAO9D,EAAKC,KAAUwR,EAAO1R,UAC9B,IACI+D,EAAM9D,GAAOkH,KAAKE,MAAMuK,mBAAmB1R,GAC/C,CAAE,MACE6D,EAAM9D,GAAO2R,mBAAmB1R,EACpC,CAGJ,OAAO6D,CACX,CAAE,MAAOuJ,GAEL,MAAO,CAAA,CACX,CACJ,CAKA,YAAAoD,CAAa3M,GACT,GAAkC,IAA9BhE,OAAOiE,KAAKD,GAAO5C,OAAe,MAAO,GAE7C,IAEI,MAAM0Q,EAAO1K,KAAKC,UAAUrD,GACtB+N,EAASC,KAAKF,GAEpB,GAAIC,EAAO3Q,OAAS/C,KAAK+P,aACrB,OAAO2D,EAIX,MAAMJ,EAAS,IAAIC,gBAEnB,IAAK,MAAO1R,EAAKC,KAAUH,OAAOC,QAAQ+D,GACtC,GAAI7D,QAAuC,CACvC,MAAM8R,EAA8B,iBAAV9R,EACpBiH,KAAKC,UAAUlH,GACfL,OAAOK,GACbwR,EAAOxS,IAAIe,EAAK+R,EACpB,CAGJ,OAAON,EAAOO,UAClB,CAAE,MAAO3E,GAEL,MAAO,EACX,CACJ,CAKA,UAAAwD,CAAWK,GAEP,GADoB5B,OAAO6B,SAASD,KAAKE,UAAU,KAC/BF,EAAM,CAEtB,MAAMe,EAASf,EAAO,GAAG5B,OAAO6B,SAASe,YAAYhB,IAAS5B,OAAO6B,SAASe,SAC9E5C,OAAO6C,QAAQC,aAAa,KAAM,GAAIH,EAC1C,CACJ,CAKA,kBAAAnB,CAAmBhN,GACf,MAAM0L,EAAWrR,KAAK6S,kBAAkBlN,GAExCwL,OAAO6C,QAAQC,aACX,CAAE5C,WAAU3B,UAAWhH,KAAK0J,OAC5Bb,SAAS2C,MACT/C,OAAO6B,SAASmB,KAExB,CAKA,iBAAAtB,CAAkBD,GACd,MAAMvB,EAAW,CAAA,EAEjB,IAAK,MAAO+C,EAAUtS,KAAUH,OAAOC,QAAQgR,GAAW,CACtD,MAAMyB,EAAUrU,KAAK6Q,iBAAiBuD,GAClCC,IACAhD,EAASgD,GAAWvS,EAE5B,CAEA,OAAOuP,CACX,CAKA,eAAAyB,CAAgBzB,GAERA,EAASnM,SACTqM,SAAS+C,cAAc,IAAIC,YAAY,kBAAmB,CACtD9C,OAAQ,CAAEvM,QAASmM,EAASnM,YAKhCmM,EAASvR,QACTyR,SAAS+C,cAAc,IAAIC,YAAY,iBAAkB,CACrD9C,OAAQJ,EAASvR,UAKrBuR,EAASjB,cACT/M,EAAMmR,SAAS,CACXpE,aAAcpQ,KAAKyU,aAAapD,EAASjB,gBAK7CiB,EAASf,WACTjN,EAAMmR,SAAS,CAAElE,UAAWe,EAASf,YAIrCe,EAASd,WACTlN,EAAMmR,SAAS,CAAEjE,UAAWc,EAASd,YAIrCc,EAASb,OACTe,SAAS+C,cAAc,IAAIC,YAAY,aAAc,CACjD9C,OAAQ,CAAEjB,MAAOa,EAASb,UAK9Ba,EAASZ,QACTc,SAAS+C,cAAc,IAAIC,YAAY,cAAe,CAClD9C,OAAQ,CAAEhB,OAAQY,EAASZ,WAK/BY,EAASX,eACTa,SAAS+C,cAAc,IAAIC,YAAY,wBAAyB,CAC5D9C,OAAQ,CAAEf,cAAe,IAAI1M,IAAIqN,EAASX,mBAK9CW,EAASV,aACTY,SAAS+C,cAAc,IAAIC,YAAY,wBAAyB,CAC5D9C,OAAQJ,EAASV,cAG7B,CAKA,YAAA8D,CAAa7Q,GACT,MAAMrD,MAAEA,GAAU8C,EAAMC,WACxB,OAAO/C,EAAMgE,KAAK5D,GAAQA,EAAKI,GAAG8S,aAAejQ,EAAOiQ,WAC5D,CAKA,aAAArB,CAAc7M,GACV,MAAM+O,EAAa,CAAA,GAGbC,GAAEA,KAAOC,GAA0BjP,EAGzC,IAAK,MAAO9D,EAAKC,KAAUH,OAAOC,QAAQgT,GAClCtO,MAAMO,QAAQ/E,GAEVA,EAAMiB,OAAS,IACf2R,EAAW7S,GAAOC,GAEE,iBAAVA,GAAgC,OAAVA,EAEhCH,OAAOiE,KAAK9D,GAAOiB,OAAS,IAC5B2R,EAAW7S,GAAOC,GAEfA,SAAmD,KAAVA,IAChD4S,EAAW7S,GAAOC,GAI1B,OAAO4S,CACX,CAKA,eAAAxB,CAAgB2B,GACZ,IAGI,MAAMzB,EAAUC,KAAKwB,GACrB,OAAO9L,KAAKE,MAAMmK,EACtB,CAAE,MAAOlE,GAEL,MAAO,CAAA,CACX,CACJ,CAKA,QAAAiE,CAAS2B,GACL,IACI,OAAOnB,KAAKN,KAAKyB,MAAUA,CAC/B,CAAE,MACE,OAAO,CACX,CACJ,CAKA,oBAAAC,CAAqB7S,EAAU,IAC3B,MAAM8S,YACFA,GAAc,EAAIC,eAClBA,GAAiB,EAAIC,cACrBA,GAAgB,EAAIC,iBACpBA,GAAmB,EAAIC,mBACvBA,GAAqB,GACrBlT,EAEEgQ,EAAelS,KAAKmS,eACpBkD,EAAa,CAAA,EAGnBA,EAAWC,EAAItV,KAAK8P,aAGhBmF,GAAkB/C,EAAalS,KAAKmQ,UAAUjL,WAC9CmQ,EAAWrV,KAAKmQ,UAAUjL,SAAWgN,EAAalS,KAAKmQ,UAAUjL,UAGjEgQ,GAAiBhD,EAAalS,KAAKmQ,UAAUrQ,UAC7CuV,EAAWrV,KAAKmQ,UAAUrQ,QAAUoS,EAAalS,KAAKmQ,UAAUrQ,SAGhEqV,IACIjD,EAAalS,KAAKmQ,UAAUC,gBAC5BiF,EAAWrV,KAAKmQ,UAAUC,cAAgB8B,EAAalS,KAAKmQ,UAAUC,eAEtE8B,EAAalS,KAAKmQ,UAAUE,gBAC5BgF,EAAWrV,KAAKmQ,UAAUE,cAAgB6B,EAAalS,KAAKmQ,UAAUE,gBAI1E2E,IACI9C,EAAalS,KAAKmQ,UAAUG,aAC5B+E,EAAWrV,KAAKmQ,UAAUG,WAAa4B,EAAalS,KAAKmQ,UAAUG,YAEnE4B,EAAalS,KAAKmQ,UAAUM,UAC5B4E,EAAWrV,KAAKmQ,UAAUM,QAAUyB,EAAalS,KAAKmQ,UAAUM,SAEhEyB,EAAalS,KAAKmQ,UAAUK,SAC5B6E,EAAWrV,KAAKmQ,UAAUK,OAAS0B,EAAalS,KAAKmQ,UAAUK,SAInE4E,GAAsBlD,EAAalS,KAAKmQ,UAAUO,iBAClD2E,EAAWrV,KAAKmQ,UAAUO,eAAiBwB,EAAalS,KAAKmQ,UAAUO,gBAG3E2E,EAAWrV,KAAKmQ,UAAUT,WAAahH,KAAK0J,MAE5C,MAAMW,EAAO/S,KAAKsS,aAAa+C,GACzBE,EAAU,GAAGpE,OAAO6B,SAASwC,aAAarE,OAAO6B,SAASyC,OAAOtE,OAAO6B,SAASe,WAEvF,OAAOhB,EAAO,GAAGwC,KAAWxC,IAASwC,CACzC,CAKA,sBAAMG,CAAiBxT,EAAU,IAC7B,IACI,MAAMyT,EAAM3V,KAAK+U,qBAAqB7S,GAEtC,GAAI0T,UAAUC,WAAa1E,OAAO2E,sBACxBF,UAAUC,UAAUE,UAAUJ,OACjC,CAEH,MAAMK,EAAWzE,SAAS0E,cAAc,YACxCD,EAASlU,MAAQ6T,EACjBpE,SAAS2E,KAAKC,YAAYH,GAC1BA,EAASI,SACT7E,SAAS8E,YAAY,QACrB9E,SAAS2E,KAAKI,YAAYN,EAC9B,CASA,OAJAzE,SAAS+C,cAAc,IAAIC,YAAY,YAAa,CAChD9C,OAAQ,CAAEkE,MAAKzT,cAGZyT,CACX,CAAE,MAAOzG,GAEL,MAAMA,CACV,CACJ,CAKA,aAAAqH,GACIpF,OAAO6C,QAAQC,aAAa,KAAM,GAAI9C,OAAO6B,SAASe,SAE1D,CAKA,eAAAyC,GACI,MAAM5D,EAAW5S,KAAKmS,eAChBd,EAAWrR,KAAK6S,kBAAkBD,GAExC,MAAO,CACH6D,QAAStF,OAAO6B,SAASD,KACzBH,WACAvB,WACAqF,UAAWvF,OAAO6B,SAASmB,KAAKpR,OAChC2R,WAAYvD,OAAO6B,SAASD,KAAK1M,WAAW,OAEpD,CAKA,aAAAsQ,CAAchR,GACV,MAAMiR,EAAS,GAGXjR,EAAM2P,GAAK3P,EAAM2P,IAAMtV,KAAK8P,cAC5B8G,EAAOrV,KAAK,2BAA2BoE,EAAM2P,QAAQtV,KAAK8P,gBAI9D,MAAM+G,EAAY,IAAI7S,IAAIrC,OAAOmV,OAAO9W,KAAKmQ,YAC7C,IAAK,MAAMtO,KAAOF,OAAOiE,KAAKD,GACrBkR,EAAUxS,IAAIxC,IAAgB,MAARA,GACvB+U,EAAOrV,KAAK,sBAAsBM,KAI1C,MAAO,CACHkV,MAAyB,IAAlBH,EAAO7T,OACd6T,SAER,CAKA,YAAAtF,CAAa3L,GACU3F,KAAK2W,cAAchR,GAEtBoR,MAIhB/W,KAAK8S,gBAAgB9S,KAAK6S,kBAAkBlN,IAG5C,MAAMoN,EAAO/S,KAAKsS,aAAa3M,GAC/B3F,KAAK0S,WAAWK,EACpB,CAKA,kBAAAiE,CAAmBnV,EAAM,oBACrB,IACI,MAAMqQ,EAAelS,KAAKmS,eAC1BtJ,aAAaC,QAAQjH,EAAKkH,KAAKC,UAAU,CACrCrD,MAAOuM,EACPxC,UAAWhH,KAAK0J,MAChBuD,IAAKxE,OAAO6B,SAASmB,OAI7B,CAAE,MAAOjF,GAET,CACJ,CAKA,oBAAA+H,CAAqBpV,EAAM,oBACvB,IACI,MAAMqV,EAAQrO,aAAaK,QAAQrH,GACnC,IAAKqV,EAAQ,OAAO,KAEpB,MAAMvR,MAAEA,EAAK+J,UAAEA,EAASiG,IAAEA,GAAQ5M,KAAKE,MAAMiO,GAI7C,OAAOvR,CACX,CAAE,MAAOuJ,GAEL,OAAO,IACX,CACJ,CAKA,YAAAiI,GACI,MAAMjF,EAAelS,KAAKmS,eACpBd,EAAWrR,KAAK6S,kBAAkBX,GAExC,MAAO,CACH/B,UAAWxO,OAAOiE,KAAKyL,GACvBqF,UAAWvF,OAAO6B,SAASmB,KAAKpR,OAChCqU,UAAWrO,KAAKC,UAAUkJ,GAAcnP,OACxCsU,aAAclG,OAAO6B,SAASD,KAAK1M,WAAW,OAC9CqJ,UAAW2B,EAAS3B,UACpB4H,aAAcjG,EAASnM,QACvBqS,YAAalG,EAASvR,OACtB0X,gBAAiBnG,EAASjB,eAAgBiB,EAAShB,cACnDoH,UAAWpG,EAASf,UACpBoH,iBAAkBrG,EAASX,cAEnC,CAKA,OAAAiH,GACQ3X,KAAKkQ,eACLhG,aAAalK,KAAKkQ,eAItBiB,OAAOyG,oBAAoB,WAAY5X,KAAKgR,kBAC5CG,OAAOyG,oBAAoB,aAAc5X,KAAKgR,iBAGlD"}