{"version":3,"file":"sw-PkmXUov2.js","sources":["../../src/sw.js"],"sourcesContent":["/**\n * Service Worker for NAS Knowledge Graph\n * Handles caching of static assets, API responses, and offline functionality\n */\n\nconst CACHE_NAME = 'nas-knowledge-graph-v1.2';\nconst STATIC_CACHE = 'static-assets-v1.2';\nconst DYNAMIC_CACHE = 'dynamic-content-v1.2';\nconst API_CACHE = 'api-responses-v1.2';\n\n// Assets to cache immediately on install\nconst STATIC_ASSETS = [\n  '/',\n  '/index.html',\n  '/assets/styles.css',\n  '/src/main-enhanced.js',\n  '/src/core/store.js',\n  '/src/core/graph.js',\n  '/src/utils/debounce.js',\n  '/data/sample-data.json',\n  '/data/sample-relations.json',\n  'https://d3js.org/d3.v7.min.js'\n];\n\n// API endpoints to cache\nconst API_ENDPOINTS = [\n  '/data/',\n  '/api/'\n];\n\n// Cache strategies\nconst CACHE_STRATEGIES = {\n  CACHE_FIRST: 'cache-first',\n  NETWORK_FIRST: 'network-first',\n  STALE_WHILE_REVALIDATE: 'stale-while-revalidate',\n  NETWORK_ONLY: 'network-only',\n  CACHE_ONLY: 'cache-only'\n};\n\n// Performance monitoring\nlet performanceMetrics = {\n  cacheHits: 0,\n  cacheMisses: 0,\n  networkRequests: 0,\n  averageResponseTime: 0,\n  totalResponseTime: 0\n};\n\n/**\n * Service Worker Installation\n */\nself.addEventListener('install', (event) => {\n  console.log('🔧 Service Worker: Installing...');\n  \n  event.waitUntil(\n    caches.open(STATIC_CACHE)\n      .then((cache) => {\n        console.log('📦 Service Worker: Caching static assets');\n        return cache.addAll(STATIC_ASSETS.map(url => new Request(url, {\n          credentials: 'same-origin'\n        })));\n      })\n      .then(() => {\n        console.log('✅ Service Worker: Installation complete');\n        // Force activation of new service worker\n        return self.skipWaiting();\n      })\n      .catch((error) => {\n        console.error('❌ Service Worker: Installation failed', error);\n      })\n  );\n});\n\n/**\n * Service Worker Activation\n */\nself.addEventListener('activate', (event) => {\n  console.log('🚀 Service Worker: Activating...');\n  \n  event.waitUntil(\n    // Clean up old caches\n    caches.keys()\n      .then((cacheNames) => {\n        return Promise.all(\n          cacheNames.map((cacheName) => {\n            if (cacheName !== STATIC_CACHE && \n                cacheName !== DYNAMIC_CACHE && \n                cacheName !== API_CACHE) {\n              console.log('🧹 Service Worker: Deleting old cache', cacheName);\n              return caches.delete(cacheName);\n            }\n          })\n        );\n      })\n      .then(() => {\n        console.log('✅ Service Worker: Activation complete');\n        // Take control of all pages\n        return self.clients.claim();\n      })\n      .catch((error) => {\n        console.error('❌ Service Worker: Activation failed', error);\n      })\n  );\n});\n\n/**\n * Fetch Event Handler with Performance Optimization\n */\nself.addEventListener('fetch', (event) => {\n  const request = event.request;\n  const url = new URL(request.url);\n  \n  // Skip non-GET requests and chrome-extension requests\n  if (request.method !== 'GET' || url.protocol === 'chrome-extension:') {\n    return;\n  }\n  \n  // Determine cache strategy based on request type\n  let strategy = getCacheStrategy(request);\n  \n  event.respondWith(\n    handleRequest(request, strategy)\n      .then((response) => {\n        // Update performance metrics\n        updatePerformanceMetrics(request, response);\n        return response;\n      })\n      .catch((error) => {\n        console.error('Service Worker: Request failed', error);\n        return createErrorResponse(request);\n      })\n  );\n});\n\n/**\n * Determine cache strategy based on request\n */\nfunction getCacheStrategy(request) {\n  const url = new URL(request.url);\n  const pathname = url.pathname;\n  \n  // Static assets - cache first\n  if (pathname.match(/\\.(css|js|png|jpg|jpeg|gif|svg|woff2?|ttf|eot)$/)) {\n    return CACHE_STRATEGIES.CACHE_FIRST;\n  }\n  \n  // HTML pages - network first with fallback\n  if (pathname.endsWith('.html') || pathname === '/') {\n    return CACHE_STRATEGIES.NETWORK_FIRST;\n  }\n  \n  // API endpoints - stale while revalidate\n  if (API_ENDPOINTS.some(endpoint => pathname.startsWith(endpoint))) {\n    return CACHE_STRATEGIES.STALE_WHILE_REVALIDATE;\n  }\n  \n  // Data files - stale while revalidate\n  if (pathname.startsWith('/data/') && pathname.endsWith('.json')) {\n    return CACHE_STRATEGIES.STALE_WHILE_REVALIDATE;\n  }\n  \n  // Default to network first\n  return CACHE_STRATEGIES.NETWORK_FIRST;\n}\n\n/**\n * Handle request based on cache strategy\n */\nasync function handleRequest(request, strategy) {\n  const startTime = performance.now();\n  \n  switch (strategy) {\n    case CACHE_STRATEGIES.CACHE_FIRST:\n      return await cacheFirst(request, startTime);\n      \n    case CACHE_STRATEGIES.NETWORK_FIRST:\n      return await networkFirst(request, startTime);\n      \n    case CACHE_STRATEGIES.STALE_WHILE_REVALIDATE:\n      return await staleWhileRevalidate(request, startTime);\n      \n    case CACHE_STRATEGIES.CACHE_ONLY:\n      return await cacheOnly(request, startTime);\n      \n    case CACHE_STRATEGIES.NETWORK_ONLY:\n    default:\n      return await networkOnly(request, startTime);\n  }\n}\n\n/**\n * Cache First Strategy\n */\nasync function cacheFirst(request, startTime) {\n  const cachedResponse = await getCachedResponse(request);\n  \n  if (cachedResponse) {\n    performanceMetrics.cacheHits++;\n    return cachedResponse;\n  }\n  \n  const networkResponse = await fetchAndCache(request, STATIC_CACHE);\n  performanceMetrics.cacheMisses++;\n  performanceMetrics.networkRequests++;\n  \n  return networkResponse;\n}\n\n/**\n * Network First Strategy\n */\nasync function networkFirst(request, startTime) {\n  try {\n    const networkResponse = await fetchAndCache(request, DYNAMIC_CACHE);\n    performanceMetrics.networkRequests++;\n    return networkResponse;\n  } catch (error) {\n    const cachedResponse = await getCachedResponse(request);\n    \n    if (cachedResponse) {\n      performanceMetrics.cacheHits++;\n      return cachedResponse;\n    }\n    \n    throw error;\n  }\n}\n\n/**\n * Stale While Revalidate Strategy\n */\nasync function staleWhileRevalidate(request, startTime) {\n  const cachedResponse = getCachedResponse(request);\n  \n  // Always try to fetch fresh version in background\n  const networkPromise = fetchAndCache(request, API_CACHE)\n    .then(() => {\n      performanceMetrics.networkRequests++;\n    })\n    .catch((error) => {\n      console.warn('Background fetch failed:', error.message);\n    });\n  \n  // Return cached version immediately if available\n  const cached = await cachedResponse;\n  if (cached) {\n    performanceMetrics.cacheHits++;\n    // Don't wait for network request\n    return cached;\n  }\n  \n  // Wait for network if no cache available\n  try {\n    const networkResponse = await networkPromise;\n    performanceMetrics.cacheMisses++;\n    return networkResponse;\n  } catch (error) {\n    throw error;\n  }\n}\n\n/**\n * Cache Only Strategy\n */\nasync function cacheOnly(request, startTime) {\n  const cachedResponse = await getCachedResponse(request);\n  \n  if (cachedResponse) {\n    performanceMetrics.cacheHits++;\n    return cachedResponse;\n  }\n  \n  throw new Error('No cached response available');\n}\n\n/**\n * Network Only Strategy\n */\nasync function networkOnly(request, startTime) {\n  performanceMetrics.networkRequests++;\n  return await fetch(request);\n}\n\n/**\n * Get cached response\n */\nasync function getCachedResponse(request) {\n  const cacheNames = [STATIC_CACHE, DYNAMIC_CACHE, API_CACHE];\n  \n  for (const cacheName of cacheNames) {\n    const cache = await caches.open(cacheName);\n    const response = await cache.match(request);\n    \n    if (response) {\n      return response;\n    }\n  }\n  \n  return null;\n}\n\n/**\n * Fetch and cache response\n */\nasync function fetchAndCache(request, cacheName) {\n  const response = await fetch(request);\n  \n  // Only cache successful responses\n  if (response.status === 200) {\n    const cache = await caches.open(cacheName);\n    // Clone the response before caching\n    await cache.put(request, response.clone());\n  }\n  \n  return response;\n}\n\n/**\n * Create error response for offline scenarios\n */\nfunction createErrorResponse(request) {\n  const url = new URL(request.url);\n  \n  // Return offline page for HTML requests\n  if (request.headers.get('accept')?.includes('text/html')) {\n    return new Response(`\n      <!DOCTYPE html>\n      <html>\n        <head>\n          <title>Offline - NAS Knowledge Graph</title>\n          <style>\n            body { \n              font-family: system-ui, sans-serif; \n              text-align: center; \n              padding: 2rem; \n              color: #333; \n            }\n            .offline-icon { \n              font-size: 4rem; \n              margin-bottom: 1rem; \n            }\n          </style>\n        </head>\n        <body>\n          <div class=\"offline-icon\">📡</div>\n          <h1>You're Offline</h1>\n          <p>The NAS Knowledge Graph is not available right now.</p>\n          <p>Please check your connection and try again.</p>\n          <button onclick=\"location.reload()\">Retry</button>\n        </body>\n      </html>\n    `, {\n      status: 200,\n      headers: { 'Content-Type': 'text/html' }\n    });\n  }\n  \n  // Return JSON error for API requests\n  if (request.headers.get('accept')?.includes('application/json')) {\n    return new Response(JSON.stringify({\n      error: 'Offline',\n      message: 'This content is not available offline'\n    }), {\n      status: 503,\n      headers: { 'Content-Type': 'application/json' }\n    });\n  }\n  \n  // Generic error response\n  return new Response('Service Unavailable', { status: 503 });\n}\n\n/**\n * Update performance metrics\n */\nfunction updatePerformanceMetrics(request, response) {\n  const responseTime = performance.now() - Date.now();\n  \n  performanceMetrics.totalResponseTime += responseTime;\n  const totalRequests = performanceMetrics.cacheHits + \n                       performanceMetrics.cacheMisses + \n                       performanceMetrics.networkRequests;\n  \n  if (totalRequests > 0) {\n    performanceMetrics.averageResponseTime = \n      performanceMetrics.totalResponseTime / totalRequests;\n  }\n  \n  // Log performance stats every 100 requests\n  if (totalRequests % 100 === 0) {\n    console.log('📊 Service Worker Performance Stats:', {\n      cacheHitRate: Math.round((performanceMetrics.cacheHits / totalRequests) * 100) + '%',\n      averageResponseTime: Math.round(performanceMetrics.averageResponseTime) + 'ms',\n      totalRequests: totalRequests\n    });\n  }\n}\n\n/**\n * Handle messages from main thread\n */\nself.addEventListener('message', (event) => {\n  const { type, payload } = event.data;\n  \n  switch (type) {\n    case 'GET_PERFORMANCE_STATS':\n      event.ports[0].postMessage(performanceMetrics);\n      break;\n      \n    case 'CLEAR_CACHE':\n      clearCache(payload.cacheName)\n        .then(() => {\n          event.ports[0].postMessage({ success: true });\n        })\n        .catch((error) => {\n          event.ports[0].postMessage({ error: error.message });\n        });\n      break;\n      \n    case 'PRECACHE_URLS':\n      precacheUrls(payload.urls)\n        .then(() => {\n          event.ports[0].postMessage({ success: true });\n        })\n        .catch((error) => {\n          event.ports[0].postMessage({ error: error.message });\n        });\n      break;\n      \n    default:\n      console.warn('Unknown message type:', type);\n  }\n});\n\n/**\n * Clear specific cache\n */\nasync function clearCache(cacheName) {\n  if (cacheName) {\n    return await caches.delete(cacheName);\n  } else {\n    // Clear all caches\n    const cacheNames = await caches.keys();\n    return await Promise.all(\n      cacheNames.map(name => caches.delete(name))\n    );\n  }\n}\n\n/**\n * Precache specific URLs\n */\nasync function precacheUrls(urls) {\n  const cache = await caches.open(DYNAMIC_CACHE);\n  \n  return await Promise.all(\n    urls.map(async (url) => {\n      try {\n        const response = await fetch(url);\n        if (response.ok) {\n          await cache.put(url, response);\n        }\n      } catch (error) {\n        console.warn(`Failed to precache ${url}:`, error.message);\n      }\n    })\n  );\n}\n\n/**\n * Periodic cleanup of old cache entries\n */\nself.addEventListener('periodicsync', (event) => {\n  if (event.tag === 'cleanup-cache') {\n    event.waitUntil(cleanupOldCacheEntries());\n  }\n});\n\n/**\n * Cleanup old cache entries to prevent storage bloat\n */\nasync function cleanupOldCacheEntries() {\n  const maxAge = 7 * 24 * 60 * 60 * 1000; // 7 days\n  const now = Date.now();\n  \n  const cacheNames = [DYNAMIC_CACHE, API_CACHE];\n  \n  for (const cacheName of cacheNames) {\n    const cache = await caches.open(cacheName);\n    const requests = await cache.keys();\n    \n    for (const request of requests) {\n      const response = await cache.match(request);\n      const dateHeader = response.headers.get('date');\n      \n      if (dateHeader) {\n        const cacheDate = new Date(dateHeader).getTime();\n        \n        if (now - cacheDate > maxAge) {\n          await cache.delete(request);\n          console.log('🧹 Cleaned up old cache entry:', request.url);\n        }\n      }\n    }\n  }\n}\n\nconsole.log('📡 Service Worker: Script loaded');\n"],"names":["STATIC_CACHE","DYNAMIC_CACHE","API_CACHE","STATIC_ASSETS","API_ENDPOINTS","CACHE_STRATEGIES","performanceMetrics","cacheHits","cacheMisses","networkRequests","averageResponseTime","totalResponseTime","async","getCachedResponse","request","cacheNames","cacheName","cache","caches","open","response","match","fetchAndCache","fetch","status","put","clone","self","addEventListener","event","waitUntil","then","addAll","map","url","Request","credentials","skipWaiting","catch","error","keys","Promise","all","delete","clients","claim","URL","method","protocol","strategy","pathname","endsWith","some","endpoint","startsWith","getCacheStrategy","respondWith","performance","now","cachedResponse","networkResponse","cacheFirst","networkFirst","networkPromise","cached","staleWhileRevalidate","Error","cacheOnly","networkOnly","handleRequest","responseTime","Date","totalRequests","updatePerformanceMetrics","headers","get","includes","Response","JSON","stringify","message","createErrorResponse","type","payload","data","ports","postMessage","name","clearCache","success","urls","ok","precacheUrls","tag","maxAge","requests","dateHeader","getTime","cleanupOldCacheEntries"],"mappings":"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"}