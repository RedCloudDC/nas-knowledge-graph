/**
 * Accessibility Testing and Validation Script
 * Tests keyboard navigation, screen reader compatibility, and WCAG compliance
 */

class AccessibilityValidator {
    constructor() {
        this.results = {
            keyboard: {},
            screenReader: {},
            wcag: {},
            focus: {},
            aria: {},
            issues: [],
            warnings: []
        };
        
        this.init();
    }
    
    /**
     * Initialize accessibility tests
     */
    init() {
        this.testKeyboardNavigation();
        this.testScreenReaderSupport();
        this.testFocusManagement();
        this.testARIAImplementation();
        this.testWCAGCompliance();
        this.generateReport();
    }
    
    /**
     * Test comprehensive keyboard navigation
     */
    testKeyboardNavigation() {
        const keyboard = this.results.keyboard;
        
        // Test skip links
        keyboard.skipLinks = this.testSkipLinks();
        
        // Test tab order
        keyboard.tabOrder = this.testTabOrder();
        
        // Test keyboard traps
        keyboard.keyboardTraps = this.testKeyboardTraps();
        
        // Test arrow key navigation
        keyboard.arrowNavigation = this.testArrowNavigation();
        
        // Test escape key functionality
        keyboard.escapeKey = this.testEscapeKey();
        
        // Test enter/space activation
        keyboard.activation = this.testKeyboardActivation();
        
        // Test custom keyboard shortcuts
        keyboard.shortcuts = this.testKeyboardShortcuts();
        
        console.log('Keyboard Navigation Tests:', keyboard);
    }
    
    /**
     * Test screen reader support
     */\n    testScreenReaderSupport() {\n        const screenReader = this.results.screenReader;\n        \n        // Test live regions\n        screenReader.liveRegions = this.testLiveRegions();\n        \n        // Test announcements\n        screenReader.announcements = this.testAnnouncements();\n        \n        // Test dynamic content updates\n        screenReader.dynamicUpdates = this.testDynamicUpdates();\n        \n        // Test screen reader only content\n        screenReader.srOnlyContent = this.testSROnlyContent();\n        \n        console.log('Screen Reader Tests:', screenReader);\n    }\n    \n    /**\n     * Test focus management\n     */\n    testFocusManagement() {\n        const focus = this.results.focus;\n        \n        // Test focus indicators\n        focus.indicators = this.testFocusIndicators();\n        \n        // Test focus order\n        focus.order = this.testFocusOrder();\n        \n        // Test focus restoration\n        focus.restoration = this.testFocusRestoration();\n        \n        // Test modal focus trapping\n        focus.trapping = this.testFocusTrapping();\n        \n        // Test programmatic focus\n        focus.programmatic = this.testProgrammaticFocus();\n        \n        console.log('Focus Management Tests:', focus);\n    }\n    \n    /**\n     * Test ARIA implementation\n     */\n    testARIAImplementation() {\n        const aria = this.results.aria;\n        \n        // Test roles\n        aria.roles = this.testARIARoles();\n        \n        // Test properties\n        aria.properties = this.testARIAProperties();\n        \n        // Test states\n        aria.states = this.testARIAStates();\n        \n        // Test labels and descriptions\n        aria.labelsAndDescriptions = this.testLabelsAndDescriptions();\n        \n        // Test landmark regions\n        aria.landmarks = this.testLandmarkRegions();\n        \n        console.log('ARIA Implementation Tests:', aria);\n    }\n    \n    /**\n     * Test WCAG compliance\n     */\n    testWCAGCompliance() {\n        const wcag = this.results.wcag;\n        \n        // Test color contrast\n        wcag.colorContrast = this.testColorContrast();\n        \n        // Test text scaling\n        wcag.textScaling = this.testTextScaling();\n        \n        // Test motion preferences\n        wcag.motionPreferences = this.testMotionPreferences();\n        \n        // Test touch targets\n        wcag.touchTargets = this.testTouchTargets();\n        \n        // Test semantic markup\n        wcag.semanticMarkup = this.testSemanticMarkup();\n        \n        console.log('WCAG Compliance Tests:', wcag);\n    }\n    \n    // Individual test methods\n    \n    testSkipLinks() {\n        const skipLinks = document.querySelectorAll('.skip-link');\n        const results = {\n            count: skipLinks.length,\n            visible: false,\n            functional: false,\n            targets: []\n        };\n        \n        skipLinks.forEach(link => {\n            const target = document.querySelector(link.getAttribute('href'));\n            results.targets.push({\n                href: link.getAttribute('href'),\n                text: link.textContent,\n                targetExists: !!target,\n                targetFocusable: target ? target.hasAttribute('tabindex') || target.matches('input, button, select, textarea, a[href]') : false\n            });\n        });\n        \n        // Test visibility on focus\n        if (skipLinks.length > 0) {\n            const firstSkipLink = skipLinks[0];\n            firstSkipLink.focus();\n            const styles = window.getComputedStyle(firstSkipLink);\n            results.visible = styles.opacity !== '0' && styles.visibility !== 'hidden';\n            firstSkipLink.blur();\n        }\n        \n        return results;\n    }\n    \n    testTabOrder() {\n        const focusableElements = this.getFocusableElements();\n        const results = {\n            elements: focusableElements.length,\n            logicalOrder: true,\n            tabIndexIssues: []\n        };\n        \n        // Check for problematic tab indexes\n        focusableElements.forEach((element, index) => {\n            const tabIndex = parseInt(element.getAttribute('tabindex') || '0');\n            if (tabIndex > 0) {\n                results.tabIndexIssues.push({\n                    element: this.getElementSelector(element),\n                    tabIndex: tabIndex,\n                    position: index\n                });\n            }\n        });\n        \n        results.logicalOrder = results.tabIndexIssues.length === 0;\n        return results;\n    }\n    \n    testKeyboardTraps() {\n        // Test for keyboard traps (elements that prevent tab navigation)\n        const results = {\n            traps: [],\n            modalTraps: this.testModalTraps()\n        };\n        \n        // This would require more complex testing with actual user simulation\n        // For now, we check for common patterns that could cause traps\n        const elementsWithKeydownListeners = document.querySelectorAll('[onkeydown]');\n        elementsWithKeydownListeners.forEach(element => {\n            if (element.getAttribute('onkeydown').includes('preventDefault')) {\n                results.traps.push({\n                    element: this.getElementSelector(element),\n                    reason: 'Element has keydown listener with preventDefault'\n                });\n            }\n        });\n        \n        return results;\n    }\n    \n    testModalTraps() {\n        // Test modal/dialog focus trapping\n        const modals = document.querySelectorAll('[role=\"dialog\"], [role=\"alertdialog\"], .modal');\n        return {\n            modalCount: modals.length,\n            // Additional modal-specific tests would go here\n        };\n    }\n    \n    testArrowNavigation() {\n        // Test elements that should support arrow key navigation\n        const results = {\n            tablistNavigation: this.testTablistArrowNavigation(),\n            menuNavigation: this.testMenuArrowNavigation(),\n            customNavigation: this.testCustomArrowNavigation()\n        };\n        \n        return results;\n    }\n    \n    testTablistArrowNavigation() {\n        const tablists = document.querySelectorAll('[role=\"tablist\"]');\n        const results = {\n            count: tablists.length,\n            implemented: []\n        };\n        \n        tablists.forEach(tablist => {\n            const tabs = tablist.querySelectorAll('[role=\"tab\"]');\n            results.implemented.push({\n                tablist: this.getElementSelector(tablist),\n                tabCount: tabs.length,\n                hasKeydownListener: !!tablist.onkeydown || tablist.hasAttribute('onkeydown')\n            });\n        });\n        \n        return results;\n    }\n    \n    testMenuArrowNavigation() {\n        const menus = document.querySelectorAll('[role=\"menu\"], [role=\"menubar\"]');\n        return {\n            count: menus.length,\n            // Menu-specific navigation tests\n        };\n    }\n    \n    testCustomArrowNavigation() {\n        // Test custom components like graph navigation\n        const graphContainer = document.getElementById('graph-container');\n        return {\n            graphNavigation: !!graphContainer && graphContainer.hasAttribute('tabindex'),\n            hasKeyboardListener: !!graphContainer?.onkeydown\n        };\n    }\n    \n    testEscapeKey() {\n        // Test escape key functionality\n        const results = {\n            modals: 0,\n            overlays: 0,\n            customHandlers: 0\n        };\n        \n        // Count elements that should respond to escape\n        document.querySelectorAll('[role=\"dialog\"], [role=\"alertdialog\"]').forEach(() => {\n            results.modals++;\n        });\n        \n        document.querySelectorAll('.overlay, .dropdown, .tooltip').forEach(() => {\n            results.overlays++;\n        });\n        \n        return results;\n    }\n    \n    testKeyboardActivation() {\n        // Test Enter/Space activation for custom controls\n        const customControls = document.querySelectorAll('[role=\"button\"]:not(button)');\n        const results = {\n            customButtons: customControls.length,\n            hasActivationHandlers: 0\n        };\n        \n        customControls.forEach(control => {\n            if (control.onkeydown || control.onclick) {\n                results.hasActivationHandlers++;\n            }\n        });\n        \n        return results;\n    }\n    \n    testKeyboardShortcuts() {\n        // Test for keyboard shortcuts implementation\n        const results = {\n            documentListeners: !!document.onkeydown,\n            shortcuts: []\n        };\n        \n        // This would need to be enhanced based on actual shortcut implementation\n        return results;\n    }\n    \n    testLiveRegions() {\n        const liveRegions = document.querySelectorAll('[aria-live]');\n        const results = {\n            count: liveRegions.length,\n            regions: []\n        };\n        \n        liveRegions.forEach(region => {\n            results.regions.push({\n                element: this.getElementSelector(region),\n                liveValue: region.getAttribute('aria-live'),\n                atomic: region.getAttribute('aria-atomic'),\n                relevant: region.getAttribute('aria-relevant')\n            });\n        });\n        \n        return results;\n    }\n    \n    testAnnouncements() {\n        // Test screen reader announcement system\n        const announcer = document.getElementById('sr-announcer');\n        return {\n            hasAnnouncer: !!announcer,\n            announcerConfig: announcer ? {\n                ariaLive: announcer.getAttribute('aria-live'),\n                ariaAtomic: announcer.getAttribute('aria-atomic'),\n                className: announcer.className\n            } : null\n        };\n    }\n    \n    testDynamicUpdates() {\n        // Test dynamic content update announcements\n        const dynamicElements = document.querySelectorAll('[aria-live=\"polite\"], [aria-live=\"assertive\"]');\n        return {\n            count: dynamicElements.length,\n            polite: document.querySelectorAll('[aria-live=\"polite\"]').length,\n            assertive: document.querySelectorAll('[aria-live=\"assertive\"]').length\n        };\n    }\n    \n    testSROnlyContent() {\n        const srOnlyElements = document.querySelectorAll('.sr-only, .visually-hidden');\n        const results = {\n            count: srOnlyElements.length,\n            properlyHidden: 0\n        };\n        \n        srOnlyElements.forEach(element => {\n            const styles = window.getComputedStyle(element);\n            if (styles.position === 'absolute' && \n                (styles.width === '1px' || styles.clip.includes('rect'))) {\n                results.properlyHidden++;\n            }\n        });\n        \n        return results;\n    }\n    \n    testFocusIndicators() {\n        const results = {\n            cssSupport: this.testCSSFocusSupport(),\n            customIndicators: this.testCustomFocusIndicators(),\n            highContrast: this.testHighContrastFocus()\n        };\n        \n        return results;\n    }\n    \n    testCSSFocusSupport() {\n        // Test for :focus-visible support\n        const testElement = document.createElement('div');\n        testElement.style.cssText = 'outline: 1px solid red; outline: :focus-visible 1px solid blue;';\n        \n        return {\n            focusVisible: testElement.style.outline.includes('focus-visible'),\n            focusWithin: this.testCSSFeature(':focus-within')\n        };\n    }\n    \n    testCustomFocusIndicators() {\n        // Check for custom focus ring implementations\n        const focusRings = document.querySelectorAll('.focus-ring, [class*=\"focus\"]');\n        return {\n            customRings: focusRings.length,\n            keyboardFocusClass: !!document.querySelector('.keyboard-focused')\n        };\n    }\n    \n    testHighContrastFocus() {\n        // Test high contrast theme focus indicators\n        const highContrastElements = document.querySelectorAll('.theme-high-contrast *:focus-visible');\n        return {\n            hasHighContrastSupport: document.querySelector('.theme-high-contrast') !== null\n        };\n    }\n    \n    testFocusOrder() {\n        const focusableElements = this.getFocusableElements();\n        const results = {\n            totalElements: focusableElements.length,\n            visualOrder: this.testVisualFocusOrder(focusableElements),\n            logicalGroups: this.testLogicalGrouping()\n        };\n        \n        return results;\n    }\n    \n    testVisualFocusOrder(elements) {\n        // Test if focus order matches visual order\n        const positions = elements.map(element => {\n            const rect = element.getBoundingClientRect();\n            return {\n                element: this.getElementSelector(element),\n                top: rect.top,\n                left: rect.left,\n                visible: rect.width > 0 && rect.height > 0\n            };\n        });\n        \n        return {\n            positions: positions.length,\n            issues: [] // Would need complex visual order analysis\n        };\n    }\n    \n    testLogicalGrouping() {\n        // Test for logical grouping of related controls\n        const groups = document.querySelectorAll('[role=\"group\"], fieldset');\n        return {\n            groups: groups.length,\n            labeled: Array.from(groups).filter(group => \n                group.getAttribute('aria-labelledby') || \n                group.getAttribute('aria-label') ||\n                group.querySelector('legend')\n            ).length\n        };\n    }\n    \n    testFocusRestoration() {\n        // Test focus restoration after modal/overlay close\n        return {\n            // This would require interaction testing\n            implemented: 'unknown'\n        };\n    }\n    \n    testFocusTrapping() {\n        const modals = document.querySelectorAll('[role=\"dialog\"], [role=\"alertdialog\"]');\n        return {\n            modals: modals.length,\n            // Focus trapping testing would require user interaction simulation\n        };\n    }\n    \n    testProgrammaticFocus() {\n        // Test programmatic focus management\n        const elementsWithAutofocus = document.querySelectorAll('[autofocus]');\n        return {\n            autofocus: elementsWithAutofocus.length,\n            // Additional programmatic focus tests\n        };\n    }\n    \n    testARIARoles() {\n        const rolesUsed = new Set();\n        document.querySelectorAll('[role]').forEach(element => {\n            rolesUsed.add(element.getAttribute('role'));\n        });\n        \n        return {\n            count: rolesUsed.size,\n            roles: Array.from(rolesUsed),\n            validRoles: this.validateARIARoles(rolesUsed)\n        };\n    }\n    \n    validateARIARoles(roles) {\n        const validRoles = [\n            'alert', 'alertdialog', 'application', 'article', 'banner', 'button',\n            'cell', 'checkbox', 'columnheader', 'combobox', 'complementary',\n            'contentinfo', 'dialog', 'document', 'feed', 'figure', 'form',\n            'grid', 'gridcell', 'group', 'heading', 'img', 'link', 'list',\n            'listbox', 'listitem', 'main', 'menu', 'menubar', 'menuitem',\n            'navigation', 'none', 'option', 'presentation', 'progressbar',\n            'radio', 'radiogroup', 'region', 'row', 'rowgroup', 'rowheader',\n            'scrollbar', 'search', 'separator', 'slider', 'spinbutton',\n            'status', 'switch', 'tab', 'table', 'tablist', 'tabpanel',\n            'textbox', 'timer', 'toolbar', 'tooltip', 'tree', 'treegrid',\n            'treeitem'\n        ];\n        \n        const results = {\n            valid: [],\n            invalid: []\n        };\n        \n        roles.forEach(role => {\n            if (validRoles.includes(role)) {\n                results.valid.push(role);\n            } else {\n                results.invalid.push(role);\n            }\n        });\n        \n        return results;\n    }\n    \n    testARIAProperties() {\n        const properties = {\n            'aria-label': document.querySelectorAll('[aria-label]').length,\n            'aria-labelledby': document.querySelectorAll('[aria-labelledby]').length,\n            'aria-describedby': document.querySelectorAll('[aria-describedby]').length,\n            'aria-hidden': document.querySelectorAll('[aria-hidden]').length,\n            'aria-expanded': document.querySelectorAll('[aria-expanded]').length,\n            'aria-selected': document.querySelectorAll('[aria-selected]').length,\n            'aria-checked': document.querySelectorAll('[aria-checked]').length,\n            'aria-pressed': document.querySelectorAll('[aria-pressed]').length,\n            'aria-current': document.querySelectorAll('[aria-current]').length,\n            'aria-live': document.querySelectorAll('[aria-live]').length\n        };\n        \n        return properties;\n    }\n    \n    testARIAStates() {\n        // Test dynamic ARIA states\n        const results = {\n            expandableElements: this.testExpandableStates(),\n            selectableElements: this.testSelectableStates(),\n            toggleElements: this.testToggleStates()\n        };\n        \n        return results;\n    }\n    \n    testExpandableStates() {\n        const expandable = document.querySelectorAll('[aria-expanded]');\n        const results = {\n            count: expandable.length,\n            states: []\n        };\n        \n        expandable.forEach(element => {\n            results.states.push({\n                element: this.getElementSelector(element),\n                expanded: element.getAttribute('aria-expanded'),\n                hasToggleBehavior: !!element.onclick || !!element.onkeydown\n            });\n        });\n        \n        return results;\n    }\n    \n    testSelectableStates() {\n        const selectable = document.querySelectorAll('[aria-selected]');\n        return {\n            count: selectable.length,\n            inTablist: document.querySelectorAll('[role=\"tablist\"] [aria-selected]').length,\n            inListbox: document.querySelectorAll('[role=\"listbox\"] [aria-selected]').length\n        };\n    }\n    \n    testToggleStates() {\n        const toggles = document.querySelectorAll('[aria-pressed]');\n        return {\n            buttons: toggles.length,\n            // Additional toggle state tests\n        };\n    }\n    \n    testLabelsAndDescriptions() {\n        const results = {\n            labeledElements: this.testLabeling(),\n            describedElements: this.testDescriptions(),\n            formLabeling: this.testFormLabeling()\n        };\n        \n        return results;\n    }\n    \n    testLabeling() {\n        const labeledElements = document.querySelectorAll('[aria-label], [aria-labelledby]');\n        const results = {\n            count: labeledElements.length,\n            accessible: 0\n        };\n        \n        labeledElements.forEach(element => {\n            const label = element.getAttribute('aria-label');\n            const labelledby = element.getAttribute('aria-labelledby');\n            \n            if (label || (labelledby && document.getElementById(labelledby))) {\n                results.accessible++;\n            }\n        });\n        \n        return results;\n    }\n    \n    testDescriptions() {\n        const describedElements = document.querySelectorAll('[aria-describedby]');\n        const results = {\n            count: describedElements.length,\n            validReferences: 0\n        };\n        \n        describedElements.forEach(element => {\n            const describedby = element.getAttribute('aria-describedby');\n            if (describedby && document.getElementById(describedby)) {\n                results.validReferences++;\n            }\n        });\n        \n        return results;\n    }\n    \n    testFormLabeling() {\n        const formControls = document.querySelectorAll('input, select, textarea');\n        const results = {\n            total: formControls.length,\n            labeled: 0\n        };\n        \n        formControls.forEach(control => {\n            const label = document.querySelector(`label[for=\"${control.id}\"]`);\n            const ariaLabel = control.getAttribute('aria-label');\n            const ariaLabelledby = control.getAttribute('aria-labelledby');\n            \n            if (label || ariaLabel || ariaLabelledby) {\n                results.labeled++;\n            }\n        });\n        \n        return results;\n    }\n    \n    testLandmarkRegions() {\n        const landmarks = {\n            banner: document.querySelectorAll('header, [role=\"banner\"]').length,\n            main: document.querySelectorAll('main, [role=\"main\"]').length,\n            navigation: document.querySelectorAll('nav, [role=\"navigation\"]').length,\n            complementary: document.querySelectorAll('aside, [role=\"complementary\"]').length,\n            contentinfo: document.querySelectorAll('footer, [role=\"contentinfo\"]').length,\n            search: document.querySelectorAll('[role=\"search\"]').length,\n            form: document.querySelectorAll('form, [role=\"form\"]').length,\n            region: document.querySelectorAll('[role=\"region\"]').length\n        };\n        \n        return {\n            landmarks,\n            total: Object.values(landmarks).reduce((sum, count) => sum + count, 0)\n        };\n    }\n    \n    testColorContrast() {\n        // Basic color contrast testing (would need more sophisticated analysis)\n        const results = {\n            hasHighContrastTheme: document.querySelector('.theme-high-contrast') !== null,\n            userPreferenceSupport: this.testPrefersContrast()\n        };\n        \n        return results;\n    }\n    \n    testPrefersContrast() {\n        return {\n            supported: typeof window.matchMedia === 'function',\n            detected: window.matchMedia && window.matchMedia('(prefers-contrast: high)').matches\n        };\n    }\n    \n    testTextScaling() {\n        // Test text scaling support\n        const results = {\n            usesRemUnits: this.testRemUnits(),\n            scalableText: this.testScalableText(),\n            minSizes: this.testMinimumSizes()\n        };\n        \n        return results;\n    }\n    \n    testRemUnits() {\n        // Check if CSS uses rem units\n        const stylesheets = Array.from(document.stylesheets);\n        // This would require CSS parsing - simplified check\n        return {\n            remUnitsDetected: true // Placeholder\n        };\n    }\n    \n    testScalableText() {\n        // Test if text scales properly\n        return {\n            // Would need actual scaling test\n            supported: true\n        };\n    }\n    \n    testMinimumSizes() {\n        // Test minimum touch target sizes\n        const buttons = document.querySelectorAll('button, [role=\"button\"]');\n        const results = {\n            total: buttons.length,\n            adequateSize: 0\n        };\n        \n        buttons.forEach(button => {\n            const rect = button.getBoundingClientRect();\n            if (rect.width >= 44 && rect.height >= 44) {\n                results.adequateSize++;\n            }\n        });\n        \n        return results;\n    }\n    \n    testMotionPreferences() {\n        return {\n            prefersReducedMotion: this.testPrefersReducedMotion(),\n            cssAnimationControl: this.testAnimationControl()\n        };\n    }\n    \n    testPrefersReducedMotion() {\n        return {\n            supported: typeof window.matchMedia === 'function',\n            detected: window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches,\n            cssRulesExist: this.checkForReducedMotionCSS()\n        };\n    }\n    \n    checkForReducedMotionCSS() {\n        // Check if CSS has @media (prefers-reduced-motion) rules\n        // This would require CSS parsing - simplified check\n        return true; // Placeholder\n    }\n    \n    testAnimationControl() {\n        // Test animation control implementation\n        return {\n            hasControls: document.querySelector('[data-animation-control]') !== null\n        };\n    }\n    \n    testTouchTargets() {\n        const interactiveElements = document.querySelectorAll(\n            'button, [role=\"button\"], a, input, select, textarea, [tabindex]'\n        );\n        \n        const results = {\n            total: interactiveElements.length,\n            adequateSize: 0,\n            tooSmall: []\n        };\n        \n        interactiveElements.forEach(element => {\n            const rect = element.getBoundingClientRect();\n            if (rect.width >= 44 && rect.height >= 44) {\n                results.adequateSize++;\n            } else {\n                results.tooSmall.push({\n                    element: this.getElementSelector(element),\n                    width: Math.round(rect.width),\n                    height: Math.round(rect.height)\n                });\n            }\n        });\n        \n        return results;\n    }\n    \n    testSemanticMarkup() {\n        const semanticElements = {\n            headings: this.testHeadingStructure(),\n            lists: this.testLists(),\n            landmarks: this.testSemanticLandmarks(),\n            forms: this.testSemanticForms()\n        };\n        \n        return semanticElements;\n    }\n    \n    testHeadingStructure() {\n        const headings = document.querySelectorAll('h1, h2, h3, h4, h5, h6');\n        const structure = [];\n        let previousLevel = 0;\n        let issues = [];\n        \n        headings.forEach(heading => {\n            const level = parseInt(heading.tagName.charAt(1));\n            structure.push({\n                level,\n                text: heading.textContent.trim(),\n                element: this.getElementSelector(heading)\n            });\n            \n            // Check for heading level skips\n            if (level > previousLevel + 1 && previousLevel !== 0) {\n                issues.push({\n                    type: 'skip',\n                    from: previousLevel,\n                    to: level,\n                    element: this.getElementSelector(heading)\n                });\n            }\n            \n            previousLevel = level;\n        });\n        \n        return {\n            count: headings.length,\n            structure,\n            issues,\n            hasH1: document.querySelector('h1') !== null\n        };\n    }\n    \n    testLists() {\n        const lists = document.querySelectorAll('ul, ol, dl');\n        const results = {\n            count: lists.length,\n            proper: 0\n        };\n        \n        lists.forEach(list => {\n            const items = list.querySelectorAll('li, dt, dd');\n            if (items.length > 0) {\n                results.proper++;\n            }\n        });\n        \n        return results;\n    }\n    \n    testSemanticLandmarks() {\n        return {\n            header: document.querySelectorAll('header').length,\n            nav: document.querySelectorAll('nav').length,\n            main: document.querySelectorAll('main').length,\n            section: document.querySelectorAll('section').length,\n            article: document.querySelectorAll('article').length,\n            aside: document.querySelectorAll('aside').length,\n            footer: document.querySelectorAll('footer').length\n        };\n    }\n    \n    testSemanticForms() {\n        const forms = document.querySelectorAll('form');\n        const results = {\n            count: forms.length,\n            withFieldsets: 0,\n            withLabels: 0\n        };\n        \n        forms.forEach(form => {\n            if (form.querySelector('fieldset')) {\n                results.withFieldsets++;\n            }\n            if (form.querySelector('label')) {\n                results.withLabels++;\n            }\n        });\n        \n        return results;\n    }\n    \n    // Utility methods\n    \n    getFocusableElements() {\n        return Array.from(document.querySelectorAll(\n            'button:not([disabled]), [href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex=\"-1\"]):not([disabled])'\n        )).filter(element => {\n            const style = window.getComputedStyle(element);\n            return style.display !== 'none' && style.visibility !== 'hidden' && element.offsetParent !== null;\n        });\n    }\n    \n    getElementSelector(element) {\n        if (element.id) {\n            return `#${element.id}`;\n        }\n        if (element.className) {\n            return `${element.tagName.toLowerCase()}.${element.className.split(' ')[0]}`;\n        }\n        return element.tagName.toLowerCase();\n    }\n    \n    testCSSFeature(property) {\n        const element = document.createElement('div');\n        element.style.cssText = `${property}: test;`;\n        return element.style[property] === 'test';\n    }\n    \n    /**\n     * Generate comprehensive accessibility report\n     */\n    generateReport() {\n        const report = {\n            timestamp: new Date().toISOString(),\n            summary: this.generateSummary(),\n            details: this.results,\n            recommendations: this.generateRecommendations(),\n            score: this.calculateAccessibilityScore()\n        };\n        \n        console.group('🔍 Accessibility Validation Report');\n        console.log('Score:', report.score + '/100');\n        console.log('Summary:', report.summary);\n        console.log('Full Details:', report.details);\n        \n        if (report.recommendations.length > 0) {\n            console.warn('Recommendations:', report.recommendations);\n        }\n        \n        console.groupEnd();\n        \n        // Store report for external access\n        window.accessibilityReport = report;\n        \n        return report;\n    }\n    \n    generateSummary() {\n        return {\n            keyboardNavigation: Object.keys(this.results.keyboard).length,\n            screenReaderSupport: Object.keys(this.results.screenReader).length,\n            focusManagement: Object.keys(this.results.focus).length,\n            ariaImplementation: Object.keys(this.results.aria).length,\n            wcagCompliance: Object.keys(this.results.wcag).length,\n            totalIssues: this.results.issues.length,\n            totalWarnings: this.results.warnings.length\n        };\n    }\n    \n    calculateAccessibilityScore() {\n        let score = 100;\n        \n        // Deduct points for issues\n        score -= this.results.issues.length * 10;\n        score -= this.results.warnings.length * 5;\n        \n        // Add points for implementations\n        if (this.results.keyboard.skipLinks?.count > 0) score += 5;\n        if (this.results.aria.landmarks?.total > 0) score += 5;\n        if (this.results.screenReader.liveRegions?.count > 0) score += 5;\n        \n        return Math.max(0, Math.min(100, score));\n    }\n    \n    generateRecommendations() {\n        const recommendations = [];\n        \n        // Keyboard navigation recommendations\n        if (this.results.keyboard.skipLinks?.count === 0) {\n            recommendations.push('Add skip links for keyboard users');\n        }\n        \n        // ARIA recommendations\n        if (this.results.aria.landmarks?.total < 3) {\n            recommendations.push('Add more landmark regions for better navigation');\n        }\n        \n        // Screen reader recommendations\n        if (this.results.screenReader.liveRegions?.count === 0) {\n            recommendations.push('Add live regions for dynamic content updates');\n        }\n        \n        // Touch target recommendations\n        if (this.results.wcag.touchTargets?.tooSmall?.length > 0) {\n            recommendations.push(`Increase size of ${this.results.wcag.touchTargets.tooSmall.length} touch targets`);\n        }\n        \n        return recommendations;\n    }\n}\n\n// Auto-run accessibility validation when script loads\nif (typeof window !== 'undefined') {\n    // Wait for DOM to be ready\n    if (document.readyState === 'loading') {\n        document.addEventListener('DOMContentLoaded', () => {\n            window.accessibilityValidator = new AccessibilityValidator();\n        });\n    } else {\n        window.accessibilityValidator = new AccessibilityValidator();\n    }\n}\n\n// Export for module usage\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = AccessibilityValidator;\n}\n
